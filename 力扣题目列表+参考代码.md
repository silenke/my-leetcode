# 力扣题目列表 + 参考代码



## Part 3



### 例题

###### [283. 移动零](https://leetcode-cn.com/problems/move-zeroes/)

使用 partition 的思路

```cpp
class Solution {
public:
    void moveZeroes(vector<int>& nums) {
        
        int r = 0;
        for (int& n : nums) {
            if (n != 0) swap(nums[r++], n);
        }
    }
};
```




### 练习

###### [27. 移除元素](https://leetcode-cn.com/problems/remove-element/)

```cpp
class Solution {
public:
    int removeElement(vector<int>& nums, int val) {

        int r = 0;
        for (int n : nums) {
            if (n != val) nums[r++] = n;
        }
        return r;
    }
};
```




###### [26. 删除排序数组中的重复项](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/)

```cpp
class Solution {
public:
    int removeDuplicates(vector<int>& nums) {

        const int n = nums.size();
        if (n < 2) return n;

        int r = 0;
        for (int i = 1; i < n; i++) {
            if (nums[i] != nums[r]) {
                nums[++r] = nums[i];
            }
        }
        return r + 1;
    }
};
```



###### [80. 删除排序数组中的重复项 II](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array-ii/)

```cpp
class Solution {
public:
    int removeDuplicates(vector<int>& nums) {

        const int n = nums.size();
        if (n < 3) return n;
        
        int r = 2;
        for (int i = 2; i < n; i++) {
            if (nums[i] != nums[r - 2]) {
                nums[r++] = nums[i];
            }
        }
        return r;
    }
};
```




### 例题

###### [75. 颜色分类](https://leetcode-cn.com/problems/sort-colors/)

使用 3 路快排 partition 的思路

```cpp
class Solution {
public:
    void sortColors(vector<int>& nums) {

        int r = -1, l = nums.size();
        int i = 0;
        while (i < l) {
            if (nums[i] == 1) i++;
            else if (nums[i] == 0) swap(nums[++r], nums[i++]);
            else swap(nums[i], nums[--l]);
        }
    }
};
```



### 练习

###### [88. 合并两个有序数组](https://leetcode-cn.com/problems/merge-sorted-array/)

```cpp
class Solution {
public:
    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {

        int i = m - 1, j = n - 1;
        int k = m + n - 1;
        while (i >= 0 && j >= 0) {
            if (nums1[i] > nums2[j]) nums1[k--] = nums1[i--];
            else nums1[k--] = nums2[j--];
        }
        while (j >= 0) nums1[k--] = nums2[j--];
    }
};
```




###### [215. 数组中的第K个最大元素](https://leetcode-cn.com/problems/kth-largest-element-in-an-array/)

```cpp
class Solution {
public:
    int findKthLargest(vector<int>& nums, int k) {

        nth_element(nums.begin(), nums.end() - k, nums.end());
        return *(nums.end() - k);
    }
};
```

```cpp
class Solution {
public:
    int findKthLargest(vector<int>& nums, int k) {

        int l = 0, r = nums.size() - 1;
        while (l < r) {
            swap(nums[l], nums[l + rand() % (r - l + 1)]);
            int a = l, b = r + 1;
            int i = l + 1;
            while (i < b) {
                if (nums[i] > nums[l]) swap(nums[++a], nums[i++]);
                else if (nums[i] == nums[l]) i++;
                else swap(nums[--b], nums[i]);
            }
            swap(nums[l], nums[a]);
            if (k <= a) r = a - 1;
            else if (k <= b) break;
            else l = b;
        }
        return nums[k - 1];
    }
};
```

```cpp
class Solution {
public:
    int findKthLargest(vector<int>& nums, int k) {
        
        const int n = nums.size();
        for (int i = n / 2; i >= 0; i--) {
            shiftDown(nums, n, i);
        }
        for (int i = 0; i < k - 1; i++) {
            nums[0] = nums[n - i - 1];
            shiftDown(nums, n - i - 1, 0);
        }
        return nums[0];
    }

private:
    void shiftDown(vector<int>& nums, int n, int i) {
        
        int tmp = nums[i];
        while (i * 2 + 1 < n) {
            int j = i * 2 + 1;
            if (j + 1 < n && nums[j + 1] > nums[j]) j++;
            if (nums[j] <= tmp) break;
            nums[i] = nums[j];
            i = j;
        }
        nums[i] = tmp;
    }
};
```



### 例题

###### [167. 两数之和 II - 输入有序数组](https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/)

```cpp
class Solution {
public:
    vector<int> twoSum(vector<int>& numbers, int target) {
        
        int l = 0, r = numbers.size() - 1;
        while (l < r) {
            int sum = numbers[l] + numbers[r];
            if (sum == target) break;
            if (sum < target) l++;
            else r--;
        }
        return {l + 1, r + 1};
    }
};
```



### 练习

###### [125. 验证回文串](https://leetcode-cn.com/problems/valid-palindrome/)

```cpp
class Solution {
public:
    bool isPalindrome(string s) {

        int l = 0, r = s.size() - 1;
        while (l < r) {
            if (!isalnum(s[l])) l++;
            else if (!isalnum(s[r])) r--;
            else if (tolower(s[l++]) != tolower(s[r--])) return false;
        }
        return true;
    }
};
```



###### [344. 反转字符串](https://leetcode-cn.com/problems/reverse-string/)

```cpp
class Solution {
public:
    void reverseString(vector<char>& s) {

        for (int i = 0, j = s.size() - 1; i < j; i++, j--) {
            swap(s[i], s[j]);
        }
    }
};
```



###### [345. 反转字符串中的元音字母](https://leetcode-cn.com/problems/reverse-vowels-of-a-string/)

```cpp
class Solution {
public:
    string reverseVowels(string s) {

        bitset<128> isVowel;
        for (char c : "aeiouAEIOU") isVowel[c] = true;

        int l = 0, r = s.size() - 1;
        while (l < r) {
            if (!isVowel[s[l]]) l++;
            else if (!isVowel[s[r]]) r--;
            else swap(s[l++], s[r--]);
        }
        return s;
    }
};
```



###### [11. 盛最多水的容器](https://leetcode-cn.com/problems/container-with-most-water/)

```cpp
class Solution {
public:
    int maxArea(vector<int>& height) {

        int res = 0;
        int l = 0, r = height.size() - 1;
        while (l < r) {
            res = max(res, min(height[l], height[r]) * (r - l));
            if (height[l] < height[r]) l++;
            else r--;
        }
        return res;
    }
};
```



### 例题

###### [209. 长度最小的子数组](https://leetcode-cn.com/problems/minimum-size-subarray-sum/)

```cpp
class Solution {
public:
    int minSubArrayLen(int target, vector<int>& nums) {

        int res = INT_MAX;
        int l = 0;
        int sum = 0;
        for (int r = 0; r < nums.size(); r++) {
            sum += nums[r];
            while (sum - nums[l] >= target) {
                sum -= nums[l++];
            }
            if (sum >= target) {
                res = min(res, r - l + 1);
            }
        }
        return res == INT_MAX ? 0 : res;
    }
};
```

```cpp
class Solution {
public:
    int minSubArrayLen(int target, vector<int>& nums) {

        const int n = nums.size();
        vector<int> sums(n + 1);    // sums[i]：前i个元素的前缀和
        for (int i = 1; i <= n; i++) {
            sums[i] = sums[i - 1] + nums[i - 1];
        }

        int res = INT_MAX;
        for (int i = 0; i < n; i++) {   // 以位置i开始的最小子数组
            auto it = lower_bound(sums.begin() + i + 1, sums.end(), sums[i] + target);
            if (it != sums.end()) {
                res = min(res, static_cast<int>(it - sums.begin()) - i);
            }
            else break;
        }
        return res != INT_MAX ? res : 0;
    }
};
```



###### [3. 无重复字符的最长子串](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/)

```cpp
class Solution {
public:
    int lengthOfLongestSubstring(string s) {

        vector<int> map(128, -1);	// map[c]：字符c上次出现的位置
        int res = 0;
        int l = -1;
        for (int r = 0; r < s.size(); r++) {
            l = max(l, map[s[r]]);
            res = max(res, r - l);
            map[s[r]] = r;
        }
        return res;
    }
};
```



### 练习

###### [438. 找到字符串中所有字母异位词](https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/)

```cpp
class Solution {
public:
    vector<int> findAnagrams(string s, string p) {

        vector<int> mp(26);
        for (char c : p) mp[c - 'a']++;

        vector<int> res;
        vector<int> ms(26);
        for (int r = 0; r < s.size(); r++) {
            ms[s[r] - 'a']++;
            int l = r - p.size() + 1;
            if (l >= 0) {
                if (ms == mp) res.emplace_back(l);
                ms[s[l] - 'a']--;
            }
        }
        return res;
    }
};
```

```cpp
class Solution {
public:
    vector<int> findAnagrams(string s, string p) {

        vector<int> mp(128);
        for (char c : p) mp[c]++;

        vector<int> res;
        vector<int> ms(128);
        int l = 0;
        for (int r = 0; r < s.size(); r++) {
            ms[s[r]]++;
            while (ms[s[r]] > mp[s[r]]) {
                ms[s[l++]]--;
            }
            if (r - l + 1 == p.size()) {
                res.emplace_back(l);
            }
        }
        return res;
    }
};
```




###### [76. 最小覆盖子串](https://leetcode-cn.com/problems/minimum-window-substring/)

```cpp
class Solution {
public:
    string minWindow(string s, string t) {

        vector<int> map(128);
        for (char c : t) map[c]++;

        int minLen = INT_MAX, minLeft = -1;
        int count = t.size();
        int l = 0;
        for (int r = 0; r < s.size(); r++) {
            if (map[s[r]]-- > 0) count--;
            while (count == 0) {
                int len = r - l + 1;
                if (len < minLen) {
                    minLen = len;
                    minLeft = l;
                }
                if (++map[s[l++]] > 0) count++;
            }
        }
        return minLeft == -1 ? "" : s.substr(minLeft, minLen);
    }
};
```



## Part 4



### 例题

###### [349. 两个数组的交集](https://leetcode-cn.com/problems/intersection-of-two-arrays/)

```cpp
class Solution {
public:
    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {

        unordered_set<int> set(nums1.begin(), nums1.end());

        vector<int> res;
        for (int n : nums2) {
            auto it = set.find(n);
            if (it != set.end()) {
                res.emplace_back(n);
                set.erase(it);
            }
        }
        return res;
    }
};
```



###### [350. 两个数组的交集 II](https://leetcode-cn.com/problems/intersection-of-two-arrays-ii/)

```cpp
class Solution {
public:
    vector<int> intersect(vector<int>& nums1, vector<int>& nums2) {

        unordered_map<int, int> map;
        for (int n : nums1) map[n]++;

        vector<int> res;
        for (int n : nums2) {
            auto it = map.find(n);
            if (it != map.end()) {
                res.emplace_back(n);
                if (--it->second == 0) {
                    map.erase(it);
                }
            }
        }
        return res;
    }
};
```

```cpp
class Solution {
public:
    vector<int> intersect(vector<int>& nums1, vector<int>& nums2) {

        sort(nums1.begin(), nums1.end());
        sort(nums2.begin(), nums2.end());

        vector<int> res;
        int i = 0, j = 0;
        while (i < nums1.size() && j < nums2.size()) {
            if (nums1[i] == nums2[j]) {
                res.emplace_back(nums1[i]);
                i++, j++;
            }
            else if (nums1[i] < nums2[j]) {
                i++;
            }
            else {
                j++;
            }
        }
        return res;
    }
};
```



### 练习

###### [242. 有效的字母异位词](https://leetcode-cn.com/problems/valid-anagram/)

```cpp
class Solution {
public:
    bool isAnagram(string s, string t) {

        if (s.size() != t.size()) return false;

        vector<int> map(26);
        for (int i = 0; i < s.size(); i++) {
            map[s[i] - 'a']++;
            map[t[i] - 'a']--;
        }
        for (int x : map) {
            if (x) return false;
        }
        return true;
    }
};
```



###### [202. 快乐数](https://leetcode-cn.com/problems/happy-number/)

```cpp
class Solution {
public:
    bool isHappy(int n) {

        unordered_set<int> set{1};
        while (n != 1) {
            int sum = 0;
            while (n) {
                int i = n % 10;
                sum += i * i;
                n /= 10;
            }
            n = sum;
            if (set.find(n) != set.end()) return false;
            set.insert(n);
        }
        return true;
    }
};
```

```cpp
class Solution {
public:
    bool isHappy(int n) {

        int slow = n, fast = next(n);
        while (fast != 1 && slow != fast) {
            slow = next(slow);
            fast = next(next(fast));
        }
        return fast == 1;
    }

private:
    int next(int n) {

        int sum = 0;
        while (n) {
            int i = n % 10;
            sum += i * i;
            n /= 10;
        }
        return sum;
    }
};
```



###### [290. 单词规律](https://leetcode-cn.com/problems/word-pattern/)

```cpp
class Solution {
public:
    bool wordPattern(string pattern, string s) {

        vector<int> map1(128);  // map1[c]：字符c上次出现的位置+1
        unordered_map<string, int> map2;    // map2[w]：单词w上次出现的位置+1

        int i = 0, j = 0;
        while (i < pattern.size() && j < s.size()) {
            string word;
            while (j < s.size() && s[j] != ' ') {
                word.push_back(s[j++]);
            }
            if (map1[pattern[i]] != map2[word]) return false;
            map1[pattern[i]] = map2[word] = i + 1;
            i++, j++;
        }
        return i == pattern.size() && j > s.size();
    }
};
```



###### [205. 同构字符串](https://leetcode-cn.com/problems/isomorphic-strings/)

```cpp
class Solution {
public:
    bool isIsomorphic(string s, string t) {

        vector<int> map1(128);
        vector<int> map2(128);

        for (int i = s.size() - 1; i >= 0; i--) {
            if (map1[s[i]] != map2[t[i]]) return false;
            map1[s[i]] = map2[t[i]] = i;
        }
        return true;
    }
};
```



###### [451. 根据字符出现频率排序](https://leetcode-cn.com/problems/sort-characters-by-frequency/)

```cpp
class Solution {
public:
    string frequencySort(string s) {

        vector<int> counts(128);
        for (char c : s) counts[c]++;

        vector<pair<int, char>> p;
        for (char c = 0; c < counts.size(); c++) {
            if (counts[c]) p.emplace_back(counts[c], c);
        }

        sort(p.rbegin(), p.rend());

        string res;
        for (auto [count, c] : p) {
            res.append(count, c);
        }
        return res;
    }
};
```



### 例题

###### [1. 两数之和](https://leetcode-cn.com/problems/two-sum/)

```cpp
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {

        unordered_map<int, int> map;    // map[n]：整数n上次出现的位置
        for (int i = 0; i < nums.size(); i++) {
            auto it = map.find(target - nums[i]);
            if (it != map.end()) return {it->second, i};
            map[nums[i]] = i;
        }
        return {};
    }
};
```



### 练习

###### [15. 三数之和](https://leetcode-cn.com/problems/3sum/)

```cpp
class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {

        sort(nums.begin(), nums.end());

        vector<vector<int>> res;
        const int n = nums.size();
        for (int i = 0; i < n - 2; i++) {

            if (i > 0 && nums[i] == nums[i - 1]) continue;
            if (nums[i] + nums[i + 1] + nums[i + 2] > 0) break;
            if (nums[i] + nums[n - 2] + nums[n - 1] < 0) continue;

            int l = i + 1, r = n - 1;
            while (l < r) {
                int sum = nums[i] + nums[l] + nums[r];
                if (sum == 0) {
                    res.push_back({nums[i], nums[l], nums[r]});
                    l++, r--;
                    while (l < r && nums[l] == nums[l - 1]) l++;
                    while (l < r && nums[r] == nums[r + 1]) r--;
                }
                else if (sum < 0) {
                    l++;
                }
                else {
                    r--;
                }
            }
        }
        return res;
    }
};
```



###### [18. 四数之和](https://leetcode-cn.com/problems/4sum/)

```cpp
class Solution {
public:
    vector<vector<int>> fourSum(vector<int>& nums, int target) {

        sort(nums.begin(), nums.end());

        vector<vector<int>> res;
        const int n = nums.size();
        for (int i = 0; i < n - 3; i++) {

            if (i > 0 && nums[i] == nums[i - 1]) continue;
            if (nums[i] + nums[i + 1] + nums[i + 2] + nums[i + 3] > target) break;
            if (nums[i] + nums[n - 3] + nums[n - 2] + nums[n - 1] < target) continue;

            for (int j = i + 1; j < n - 2; j++) {

                if (j > i + 1 && nums[j] == nums[j - 1]) continue;
                if (nums[i] + nums[j] + nums[j + 1] + nums[j + 2] > target) break;
                if (nums[i] + nums[j] + nums[n - 2] + nums[n - 1] < target) continue;

                int l = j + 1, r = n - 1;
                while (l < r) {
                    int sum = nums[i] + nums[j] + nums[l] + nums[r];
                    if (sum == target) {
                        res.push_back({nums[i], nums[j], nums[l], nums[r]});
                        l++, r--;
                        while (l < r && nums[l] == nums[l - 1]) l++;
                        while (l < r && nums[r] == nums[r + 1]) r--;
                    }
                    else if (sum < target) {
                        l++;
                    }
                    else {
                        r--;
                    }
                }
            }
        }
        return res;
    }
};
```



###### [16. 最接近的三数之和](https://leetcode-cn.com/problems/3sum-closest/)

```cpp
class Solution {
public:
    int threeSumClosest(vector<int>& nums, int target) {

        sort(nums.begin(), nums.end());
        
        int res = 1e5;
        const int n = nums.size();
        for (int i = 0; i < n - 2; i++) {
            
            if (i > 0 && nums[i] == nums[i - 1]) continue;

            int l = i + 1, r = n - 1;
            while (l < r) {
                int sum = nums[i] + nums[l] + nums[r];
                if (sum == target) return sum;
                if (abs(sum - target) < abs(res - target)) res = sum;
                if (sum < target) {
                    l++;
                    while (l < r && nums[l] == nums[l - 1]) l++;
                }
                else {
                    r--;
                    while (l < r && nums[r] == nums[r + 1]) r--;
                }
            }
        }
        return res;
    }
};
```



### 例题

###### [454. 四数相加 II](https://leetcode-cn.com/problems/4sum-ii/)

```cpp
class Solution {
public:
    int fourSumCount(vector<int>& A, vector<int>& B, vector<int>& C, vector<int>& D) {

        unordered_map<int, int> map;
        for (int a : A) {
            for (int b : B) {
                map[a + b]++;
            }
        }

        int res = 0;
        for (int c : C) {
            for (int d : D) {
                auto it = map.find(0 - c - d);
                if (it != map.end()) res += it->second;
            }
        }
        return res;
    }
};
```



### 练习

###### [49. 字母异位词分组](https://leetcode-cn.com/problems/group-anagrams/)

```cpp
class Solution {
public:
    vector<vector<string>> groupAnagrams(vector<string>& strs) {

        vector<vector<string>> res;
        unordered_map<string, int> map;
        for (const string& s : strs) {
            string k(s);
            sort(k.begin(), k.end());
            auto it = map.find(k);
            if (it != map.end()) {
                res[it->second].emplace_back(s);
            }
            else {
                map[k] = res.size();
                res.push_back({s});
            }
        }
        return res;
    }
};
```

```cpp
class Solution {
public:
    vector<vector<string>> groupAnagrams(vector<string>& strs) {

        const int primes[26]{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,
            41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101};
        const int mod = 1e9 + 7;

        vector<vector<string>> res;
        unordered_map<int, int> map;
        for (const string& s : strs) {
            long k = 1;
            for (char c : s) {
                k *= primes[c - 'a'];
                k %= mod;
            }
            auto it = map.find(k);
            if (it != map.end()) {
                res[it->second].emplace_back(s);
            }
            else {
                map[k] = res.size();
                res.push_back({s});
            }
        }
        return res;
    }
};
```



### 例题

###### [447. 回旋镖的数量](https://leetcode-cn.com/problems/number-of-boomerangs/)

```cpp
class Solution {
public:
    int numberOfBoomerangs(vector<vector<int>>& points) {

        const int n = points.size();
        vector<vector<int>> dis(n, vector<int>(n));
        unordered_map<int, int> counts;
        int res = 0;
        for (int i = 0; i < n; i++) {
            for (int j = i + 1; j < n; j++) {
                int x = points[i][0] - points[j][0];
                int y = points[i][1] - points[j][1];
                dis[i][j] = dis[j][i] = x * x + y * y;
            }
            for (int j = 0; j < n; j++) {
                if (i != j) counts[dis[i][j]]++;
            }
            for (auto [d, count] : counts) {
                res += count * (count - 1);
            }
            counts.clear();
        }
        return res;
    }
};
```



### 练习

###### [149. 直线上最多的点数](https://leetcode-cn.com/problems/max-points-on-a-line/)

```cpp
class Solution {
public:
    int maxPoints(vector<vector<int>>& points) {

        auto my_hash = [](const pair<int, int>& k) {
            return static_cast<size_t>(k.first) << 32 ^ k.second;
        };
        unordered_map<pair<int, int>, int, decltype(my_hash)> counts(0, my_hash);

        int res = 0;
        const int n = points.size();
        for (int i = 0; i < n; i++) {
            int same_count = 1;
            int max_count = 0;
            for (int j = i + 1; j < n; j++) {
                if (points[i] == points[j]) {
                    same_count++; 
                }
                else {
                    max_count = max(max_count, ++counts[slope(points[i], points[j])]);
                }
            }
            res = max(res, same_count + max_count);
            counts.clear();
        }
        return res;
    }

private:
    pair<int, int> slope(const vector<int>& a, const vector<int>& b) {

        int x = a[0] - b[0];
        int y = a[1] - b[1];

        if (x == 0) return {0, 1};
        if (y == 0) return {1, 0};

        int d = __gcd(x, y);
        return {x / d, y / d};
    }
};
```

```cpp
class Solution {
public:
    int maxPoints(vector<vector<int>>& points) {

        int res = 0;
        unordered_map<int, int> counts;
        const int n = points.size();
        for (int i = 0; i < n; i++) {
            int same_count = 1;
            int max_count = 0;
            for (int j = i + 1; j < n; j++) {
                if (points[i] == points[j]) {
                    same_count++;
                }
                else {
                    max_count = max(max_count, ++counts[slope(points[i], points[j])]);
                }
            }
            res = max(res, same_count + max_count);
            counts.clear();
        }
        return res;
    }

private:
    int slope(const vector<int>& a, const vector<int>& b) {

        int x = a[0] - b[0];
        int y = a[1] - b[1];

        if (x == 0) return 1;
        if (y == 0) return 1 << 16;

        int d = __gcd(x, y);
        return static_cast<unsigned int>(y / d) << 16 | (x / d);
    }
};
```



### 例题

###### [219. 存在重复元素 II](https://leetcode-cn.com/problems/contains-duplicate-ii/)

```cpp
class Solution {
public:
    bool containsNearbyDuplicate(vector<int>& nums, int k) {

        unordered_set<int> set;
        for (int i = 0; i < nums.size(); i++) {
            if (set.find(nums[i]) != set.end()) return true;
            set.insert(nums[i]);
            if (set.size() > k) set.erase(nums[i - k]);
        }
        return false;
    }
};
```



### 练习

###### [217. 存在重复元素](https://leetcode-cn.com/problems/contains-duplicate/)

```cpp
class Solution {
public:
    bool containsDuplicate(vector<int>& nums) {

        unordered_set<int> set;
        for (int n : nums) {
            if (set.find(n) != set.end()) return true;
            set.insert(n);
        }
        return false;
    }
};
```



### 例题

###### [220. 存在重复元素 III](https://leetcode-cn.com/problems/contains-duplicate-iii/)

```cpp
class Solution {
public:
    bool containsNearbyAlmostDuplicate(vector<int>& nums, int k, int t) {

        set<long> s;
        for (int i = 0; i < nums.size(); i++) {
            auto it = s.lower_bound(static_cast<long>(nums[i]) - t);
            if (it != s.end() && *it <= static_cast<long>(nums[i]) + t) return true;
            s.insert(nums[i]);
            if (s.size() > k) s.erase(nums[i - k]);
        }
        return false;
    }
};
```

```cpp
class Solution {
public:
    bool containsNearbyAlmostDuplicate(vector<int>& nums, int k, int t) {

        unordered_map<int, int> map;	// map[i]：编号为i的桶中的元素
        for (int i = 0; i < nums.size(); i++) {

            long id = getId(t, nums[i]);
            if (map.find(id) != map.end()) return true;

            auto l = map.find(id - 1);
            if (l != map.end() && static_cast<long>(nums[i]) - l->second <= t) return true;

            auto r = map.find(id + 1);
            if (r != map.end() && r->second - static_cast<long>(nums[i]) <= t) return true;

            map[id] = nums[i];
            if (map.size() > k) map.erase(getId(t, nums[i - k]));
        }
        return false;
    }

private:
    int getId(long t, long n) {

        if (n >= 0) return n / (t + 1);
        return (n + 1) / (t + 1) - 1;
    }
};
```



### 练习



## Part 5



### 例题

###### [206. 反转链表](https://leetcode-cn.com/problems/reverse-linked-list/)

```cpp
class Solution {
public:
    ListNode* reverseList(ListNode* head) {

        ListNode* prev = nullptr;
        ListNode* curr = head;
        while (curr) {
            ListNode* next = curr->next;
            curr->next = prev;
            prev = curr;
            curr = next;
        }
        return prev;
    }
};
```

```cpp
class Solution {
public:
    ListNode* reverseList(ListNode* head) {

        if (!head || !head->next) return head;

        ListNode* tail = reverseList(head->next);
        head->next->next = head;
        head->next = nullptr;
        return tail;
    }
};
```



### 练习

###### [92. 反转链表 II](https://leetcode-cn.com/problems/reverse-linked-list-ii/)

```cpp
class Solution {
public:
    ListNode* reverseBetween(ListNode* head, int left, int right) {

        ListNode dummy(0, head);
        ListNode* last = &dummy;	// 寻找Left-1位置的节点
        for (int i = 1; i < left; i++) {
            last = last->next;
        }
        ListNode* prev = last->next;
        for (int i = left; i < right; i++) {
            ListNode* curr = prev->next;    // 要移动的节点
            prev->next = curr->next;
            curr->next = last->next;
            last->next = curr;
        }
        return dummy.next;
    }
};
```



###### [83. 删除排序链表中的重复元素](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/)

```cpp
class Solution {
public:
    ListNode* deleteDuplicates(ListNode* head) {

        if (!head || !head->next) return head;

        ListNode* prev = head;
        while (prev->next) {	// 可能要删除的节点
            ListNode* curr = prev->next;
            if (curr->val == prev->val) {
                prev->next = curr->next;
                delete curr;
            }
            else {
                prev = curr;
            }
        }
        return head;
    }
};
```

```cpp
class Solution {
public:
    ListNode* deleteDuplicates(ListNode* head) {

        if (!head || !head->next) return head;

        ListNode* next = head->next = deleteDuplicates(head->next);
        if (head->val == next->val) {
            delete head;
            return next;
        }
        return head;
    }
};
```



###### [86. 分隔链表](https://leetcode-cn.com/problems/partition-list/)

```cpp
class Solution {
public:
    ListNode* partition(ListNode* head, int x) {

        ListNode dummy1, dummy2;
        ListNode* tail1 = &dummy1;
        ListNode* tail2 = &dummy2;
        while (head) {
            if (head->val < x) tail1 = tail1->next = head;
            else tail2 = tail2->next = head;
            head = head->next;
        }
        tail1->next = dummy2.next;
        tail2->next = nullptr;
        return dummy1.next;
    }
};
```

```cpp
class Solution {
public:
    ListNode* partition(ListNode* head, int x) {

        ListNode dummy(0, head);
        ListNode* last = &dummy;
        ListNode* prev = &dummy;
        while (prev->next) {    // 可能要移动的节点
            ListNode* curr = prev->next;
            if (curr->val < x) {
                if (last == prev) {
                    last = prev = curr;
                }
                else {
                    prev->next = curr->next;
                    curr->next = last->next;
                    last = last->next = curr;
                    prev = curr;
                }
            }
            else {
                prev = curr;
            }
        }
        return dummy.next;
    }
};
```



###### [328. 奇偶链表](https://leetcode-cn.com/problems/odd-even-linked-list/)

```cpp
class Solution {
public:
    ListNode* oddEvenList(ListNode* head) {

        if (!head || !head->next) return head;

        ListNode* head2 = head->next;
        ListNode* curr = head;
        while (curr->next && curr->next->next) {    // 下个奇数节点
            ListNode* next = curr->next;    // 当前偶数节点
            curr->next = next->next;
            next->next = next->next->next;
            curr = curr->next;
        }
        curr->next = head2;
        return head;
    }
};
```



###### [2. 两数相加](https://leetcode-cn.com/problems/add-two-numbers/)

```cpp
class Solution {
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {

        ListNode dummy;
        ListNode* tail = &dummy;
        int c = 0;
        while (l1 || l2 || c) {
            if (l1) c += l1->val, l1 = l1->next;
            if (l2) c += l2->val, l2 = l2->next;
            tail = tail->next = new ListNode(c % 10);
            c /= 10;
        }
        return dummy.next;
    }
};
```



###### [445. 两数相加 II](https://leetcode-cn.com/problems/add-two-numbers-ii/)

```cpp
class Solution {
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {

        l1 = reverseList(l1);
        l2 = reverseList(l2);
        
        ListNode dummy;
        ListNode* tail = &dummy;
        int c = 0;
        while (l1 || l2 || c) {
            if (l1) c += l1->val, l1 = l1->next;
            if (l2) c += l2->val, l2 = l2->next;
            tail = tail->next = new ListNode(c % 10);
            c /= 10;
        }
        return reverseList(dummy.next);
    }

private:
    ListNode* reverseList(ListNode* head) {

        ListNode* prev = nullptr;
        ListNode* curr = head;
        while (curr) {
            ListNode* next = curr->next;
            curr->next = prev;
            prev = curr;
            curr = next;
        }
        return prev;
    }
};
```

```cpp
class Solution {
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {

        stack<int> s1, s2;
        while (l1) {
            s1.emplace(l1->val);
            l1 = l1->next;
        }
        while (l2) {
            s2.emplace(l2->val);
            l2 = l2->next;
        }

        ListNode dummy;
        int c = 0;
        while (!s1.empty() || !s2.empty() || c) {
            if (!s1.empty()) c += s1.top(), s1.pop();
            if (!s2.empty()) c += s2.top(), s2.pop();
            dummy.next = new ListNode(c % 10, dummy.next);
            c /= 10;
        }
        return dummy.next;
    }
};
```



### 例题

###### [203. 移除链表元素](https://leetcode-cn.com/problems/remove-linked-list-elements/)

```cpp
class Solution {
public:
    ListNode* removeElements(ListNode* head, int val) {

        ListNode dummy(0, head);
        ListNode* prev = &dummy;
        while (prev->next) {	// 可能要删除的节点
            ListNode* curr = prev->next;
            if (curr->val == val) {
                prev->next = curr->next;
                delete curr;
            }
            else {
                prev = curr;
            }
        }
        return dummy.next;
    }
};
```

```cpp
class Solution {
public:
    ListNode* removeElements(ListNode* head, int val) {

        if (!head) return nullptr;

        ListNode* next = head->next = removeElements(head->next, val);
        if (head->val == val) {
            delete head;
            return next;
        }
        return head;
    }
};
```




### 练习

###### [82. 删除排序链表中的重复元素 II](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii/)

```cpp
class Solution {
public:
    ListNode* deleteDuplicates(ListNode* head) {

        if (!head || !head->next) return head;
        
        ListNode dummy(0, head);
        ListNode* prev = &dummy;
        while (prev->next && prev->next->next) {	// 可能要删除的节点
            ListNode* curr = prev->next;
            if (curr->val == curr->next->val) {
                int val = curr->val;
                while (curr && curr->val == val) {
                    prev->next = curr->next;
                    delete curr;
                    curr = prev->next;
                }
            }
            else {
                prev = curr;
            }
        }
        return dummy.next;
    }
};
```

```cpp
class Solution {
public:
    ListNode* deleteDuplicates(ListNode* head) {

        if (!head || !head->next) return head;

        int val = head->val;
        if (head->next->val == val) {
            while (head && head->val == val) {
                ListNode* next = head->next;
                delete head;
                head = next;
            }
            return deleteDuplicates(head);
        }
        head->next = deleteDuplicates(head->next);
        return head;
    }
};
```




###### [21. 合并两个有序链表](https://leetcode-cn.com/problems/merge-two-sorted-lists/)

```cpp
class Solution {
public:
    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {

        ListNode dummy;
        ListNode* tail = &dummy;
        while (l1 && l2) {
            if (l1->val > l2->val) swap(l1, l2);
            tail = tail->next = l1;
            l1 = l1->next;
        }
        tail->next = l1 ? l1 : l2;
        return dummy.next;
    }
};
```

```cpp
class Solution {
public:
    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {

        if (!l1) return l2;
        if (!l2) return l1;

        if (l1->val > l2->val) swap(l1, l2);
        l1->next = mergeTwoLists(l1->next, l2);
        return l1;
    }
};
```



### 例题

###### [24. 两两交换链表中的节点](https://leetcode-cn.com/problems/swap-nodes-in-pairs/)

```cpp
class Solution {
public:
    ListNode* swapPairs(ListNode* head) {

        ListNode dummy(0, head);
        ListNode* curr = &dummy;
        while (curr->next && curr->next->next) {    // 要交换的节点

            ListNode* p1 = curr->next;
            ListNode* p2 = p1->next;

            p1->next = p2->next;
            p2->next = p1;
            curr->next = p2;
            
            curr = p1;
        }
        return dummy.next;
    }
};
```



### 练习

###### [25. K 个一组翻转链表](https://leetcode-cn.com/problems/reverse-nodes-in-k-group/)

```cpp
class Solution {
public:
    ListNode* reverseKGroup(ListNode* head, int k) {

        ListNode dummy(0, head);
        int n = 0;
        while (head) {
            n++;
            head = head->next;
        }

        ListNode* last = &dummy;
        for (int i = 0; i < n / k; i++) {
            ListNode* prev = last->next;
            for (int j = 0; j < k - 1; j++) {
                ListNode* curr = prev->next;    // 要移动的节点
                prev->next = curr->next;
                curr->next = last->next;
                last->next = curr;
            }
            last = prev;
        }
        return dummy.next;
    }
};
```



###### [147. 对链表进行插入排序](https://leetcode-cn.com/problems/insertion-sort-list/)

```cpp
class Solution {
public:
    ListNode* insertionSortList(ListNode* head) {
        
        ListNode dummy;
        while (head) {  // 要插入的节点
            ListNode* prev = &dummy;
            while (prev->next && prev->next->val < head->val) {
                prev = prev->next;
            }
            ListNode* next = head->next;
            head->next = prev->next;
            prev->next = head;
            head = next;
        }
        return dummy.next;
    }
};
```

```cpp
class Solution {
public:
    ListNode* insertionSortList(ListNode* head) {

        if (!head || !head->next) return head;

        ListNode dummy(0, head);
        ListNode* tail = head;
        ListNode* curr = head->next;
        while (curr) {
            if (curr->val >= tail->val) {
                tail = curr;
            }
            else {
                ListNode* prev = &dummy;
                while (prev->next->val < curr->val) {
                    prev = prev->next;
                }
                tail->next = curr->next;
                curr->next = prev->next;
                prev->next = curr;
            }
            curr = tail->next;
        }
        return dummy.next;
    }
};
```




###### [148. 排序链表](https://leetcode-cn.com/problems/sort-list/)

```cpp
class Solution {
public:
    ListNode* sortList(ListNode* head) {

        if (!head || !head->next) return head;

        ListNode* slow = head;
        ListNode* fast = head->next;
        while (fast && fast->next) {
            slow = slow->next;
            fast = fast->next->next;
        }
        ListNode* mid = slow->next;
        slow->next = nullptr;
        return merge(sortList(head), sortList(mid));
    }

private:
    ListNode* merge(ListNode* l1, ListNode* l2) {
        
        ListNode dummy;
        ListNode* tail = &dummy;
        while (l1 && l2) {
            if (l1->val > l2->val) swap(l1, l2);
            tail = tail->next = l1;
            l1 = l1->next;
        }
        tail->next = l1 ? l1 : l2;
        return dummy.next;
    }
};
```

```cpp
class Solution {
public:
    ListNode* sortList(ListNode* head) {

        if (!head || !head->next) return head;

        ListNode dummy(0, head);
        int n = 1;
        while (head = head->next) n++;
        for (int i = 1; i < n; i += i) {
            ListNode* tail = &dummy;
            ListNode* curr = dummy.next;
            while (curr) {
                ListNode* l = curr;
                ListNode* r = split(curr, i);
                curr = split(r, i);
                auto [h, t] = merge(l, r);
                tail->next = h;
                tail = t;
            }
        }
        return dummy.next;
    }

private:
    ListNode* split(ListNode* head, int n) {

        while (--n && head) head = head->next;
        if (!head) return nullptr;
        ListNode* next = head->next;
        head->next = nullptr;
        return next;
    }

    pair<ListNode*, ListNode*> merge(ListNode* l1, ListNode* l2) {
        
        ListNode dummy;
        ListNode* tail = &dummy;
        while (l1 && l2) {
            if (l1->val > l2->val) swap(l1, l2);
            tail = tail->next = l1;
            l1 = l1->next;
        }
        tail->next = l1 ? l1 : l2;
        while (tail->next) tail = tail->next;
        return {dummy.next, tail};
    }
};
```




### 例题

###### [237. 删除链表中的节点](https://leetcode-cn.com/problems/delete-node-in-a-linked-list/)

```cpp
class Solution {
public:
    void deleteNode(ListNode* node) {
        
        ListNode* next = node->next;
        *node = *next;
        delete next;
    }
};
```



### 练习



### 例题

###### [19. 删除链表的倒数第 N 个结点](https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/)

```cpp
class Solution {
public:
    ListNode* removeNthFromEnd(ListNode* head, int n) {

        ListNode dummy(0, head);
        ListNode* fast = &dummy;
        for (int i = 0; i < n + 1; i++) {
            fast = fast->next;
        }

        ListNode* slow = &dummy;
        while (fast) {
            slow = slow->next;
            fast = fast->next;
        }
        ListNode* next = slow->next;
        slow->next = next->next;
        delete next;
        return dummy.next;
    }
};
```



### 练习

###### [61. 旋转链表](https://leetcode-cn.com/problems/rotate-list/)

```cpp
class Solution {
public:
    ListNode* rotateRight(ListNode* head, int k) {

        if (!head || !head->next) return head;

        int n = 1;
        ListNode* tail = head;
        while (tail->next) {
            n++;
            tail = tail->next;
        }
        if ((k %= n) == 0) return head;

        ListNode* newTail = head;
        while (--n > k) {
            newTail = newTail->next;
        }
        ListNode* newHead = newTail->next;
        newTail->next = nullptr;
        tail->next = head;
        return newHead;
    }
};
```



###### [143. 重排链表](https://leetcode-cn.com/problems/reorder-list/)

```cpp
public:
    void reorderList(ListNode* head) {

        if (!head || !head->next) return;

        ListNode* fast = head;
        ListNode* slow = head;
        while (fast && fast->next) {
            fast = fast->next->next;
            slow = slow->next;
        }

        fast = reverse(slow->next);
        slow->next = nullptr;
        while (fast) {
            ListNode* next = fast->next;
            fast->next = head->next;
            head->next = fast;
            head = fast->next;
            fast = next;
        }
    }

private:
    ListNode* reverse(ListNode* head) {

        ListNode* prev = nullptr;
        ListNode* curr = head;
        while (curr) {
            ListNode* next = curr->next;
            curr->next = prev;
            prev = curr;
            curr = next;
        }
        return prev;
    }
};
```



## Part 6




### 例题

###### [20. 有效的括号](https://leetcode-cn.com/problems/valid-parentheses/)

```cpp
class Solution {
public:
    bool isValid(string s) {

        unordered_map<char, char> map{{'(', ')'}, {'{', '}'}, {'[', ']'}};

        stack<char> stk;
        for (char c : s) {
            auto it = map.find(c);
            if (it != map.end()) {	// 要么是左括号
                stk.push(it->second);
            }	// 要么是右括号
            else if (!stk.empty() && stk.top() == c) {
                stk.pop();
            }
            else {
                return false;
            }
        }
        return stk.empty();
    }
};
```



### 练习

###### [150. 逆波兰表达式求值](https://leetcode-cn.com/problems/evaluate-reverse-polish-notation/)

```cpp
class Solution {
public:
    int evalRPN(vector<string>& tokens) {

        stack<int> s;
        for (const string& str : tokens) {
            if (isdigit(str.back())) {
                s.emplace(stoi(str));
                continue;
            }
            int a = s.top(); s.pop();
            int b = s.top(); s.pop();
            switch (str.back()) {
                case '+' : b += a; break;
                case '-' : b -= a; break;
                case '*' : b *= a; break;
                case '/' : b /= a; break;
            }
            s.emplace(b);
        }
        return s.top();
    }
};
```



###### [71. 简化路径](https://leetcode-cn.com/problems/simplify-path/)

```cpp
class Solution {
public:
    string simplifyPath(string path) {

        vector<string> stk;
        istringstream i(path);
        string j;
        while (getline(i, j, '/')) {
            if (j == "" || j == ".") continue;
            if (j != "..") stk.emplace_back(j);
            else if (!stk.empty()) stk.pop_back();
        }
        if (stk.empty()) return "/";
        string res;
        for (string& s : stk) {
            res.append("/" + s);
        }
        return res;
    }
};
```



### 例题

###### [144. 二叉树的前序遍历](https://leetcode-cn.com/problems/binary-tree-preorder-traversal/)

```cpp
class Solution {
public:
    vector<int> preorderTraversal(TreeNode* root) {

        vector<int> res;
        function<void(TreeNode*)> dfs = [&](TreeNode* root) {
            if (!root) return;
            res.emplace_back(root->val);
            dfs(root->left);
            dfs(root->right);
        };
        dfs(root);
        return res;
    }
};
```


```cpp
class Solution {
public:
    vector<int> preorderTraversal(TreeNode* root) {

        vector<int> res;
        stack<pair<bool, TreeNode*>> s;
        if (root) s.emplace(false, root);
        while (!s.empty()) {
            auto [print, curr] = s.top(); s.pop();
            if (print) {
                res.emplace_back(curr->val);
            }
            else {
                if (curr->right) s.emplace(false, curr->right);
                if (curr->left) s.emplace(false, curr->left);
                s.emplace(true, curr);
            }
        }
        return res;
    }
};
```


```cpp
class Solution {
public:
    vector<int> preorderTraversal(TreeNode* root) {

        vector<int> res;
        stack<TreeNode*> s;
        if (root) s.emplace(root);
        while (!s.empty()) {
            root = s.top(); s.pop();
            res.emplace_back(root->val);
            if (root->right) s.emplace(root->right);
            if (root->left) s.emplace(root->left);
        }
        return res;
    }
};
```


```cpp
class Solution {
public:
    vector<int> preorderTraversal(TreeNode* root) {

        vector<int> res;
        while (root) {
            TreeNode* left = root->left;
            if (left) {
                while (left->right && left->right != root) {
                    left = left->right;
                }
                if (!left->right) {
                    res.emplace_back(root->val);
                    left->right = root;
                    root = root->left;
                }
                else {
                    left->right = nullptr;
                    root = root->right;
                }
            }
            else {
                res.emplace_back(root->val);
                root = root->right;
            }
        }
        return res;
    }
};
```



###### [94. 二叉树的中序遍历](https://leetcode-cn.com/problems/binary-tree-inorder-traversal/)

```cpp
class Solution {
public:
    vector<int> inorderTraversal(TreeNode* root) {

        vector<int> res;
        function<void(TreeNode*)> dfs = [&](TreeNode* root) {
            if (!root) return;
            dfs(root->left);
            res.emplace_back(root->val);
            dfs(root->right);
        };
        dfs(root);
        return res;
    }
};
```


```cpp
class Solution {
public:
    vector<int> inorderTraversal(TreeNode* root) {

        vector<int> res;
        stack<pair<bool, TreeNode*>> s;
        if (root) s.emplace(false, root);
        while (!s.empty()) {
            auto [print, curr] = s.top(); s.pop();
            if (print) {
                res.emplace_back(curr->val);
            }
            else {
                if (curr->right) s.emplace(false, curr->right);
                s.emplace(true, curr);
                if (curr->left) s.emplace(false, curr->left);
            }
        }
        return res;
    }
};
```


```cpp
class Solution {
public:
    vector<int> inorderTraversal(TreeNode* root) {

        vector<int> res;
        stack<TreeNode*> s;
        while (root || !s.empty()) {
            if (root) {
                s.emplace(root);
                root = root->left;
            }
            else {
                root = s.top(); s.pop();
                res.emplace_back(root->val);
                root = root->right;
            }
        }
        return res;
    }
};
```


```cpp
class Solution {
public:
    vector<int> inorderTraversal(TreeNode* root) {

        vector<int> res;
        while (root) {
            TreeNode* left = root->left;
            if (left) {
                while (left->right && left->right != root) {
                    left = left->right;
                }
                if (!left->right) {
                    left->right = root;
                    root = root->left;
                    continue;
                }
                left->right = nullptr;
            }
            res.emplace_back(root->val);
            root = root->right;
        }
        return res;
    }
};
```



###### [145. 二叉树的后序遍历](https://leetcode-cn.com/problems/binary-tree-postorder-traversal/)

```cpp
class Solution {
public:
    vector<int> postorderTraversal(TreeNode* root) {

        vector<int> res;
        function<void(TreeNode*)> dfs = [&](TreeNode* root) {
            if (!root) return;
            dfs(root->left);
            dfs(root->right);
            res.emplace_back(root->val);
        };
        dfs(root);
        return res;
    }
};
```


```cpp
class Solution {
public:
    vector<int> postorderTraversal(TreeNode* root) {

        vector<int> res;
        stack<pair<bool, TreeNode*>> s;
        if (root) s.emplace(false, root);
        while (!s.empty()) {
            auto [print, curr] = s.top(); s.pop();
            if (print) {
                res.emplace_back(curr->val);
            }
            else {
                s.emplace(true, curr);
                if (curr->right) s.emplace(false, curr->right);
                if (curr->left) s.emplace(false, curr->left);
            }
        }
        return res;
    }
};
```


```cpp
class Solution {
public:
    vector<int> postorderTraversal(TreeNode* root) {

        vector<int> res;
        stack<TreeNode*> s;
        if (root) s.emplace(root);
        while (!s.empty()) {
            root = s.top(); s.pop();
            res.emplace_back(root->val);
            if (root->left) s.emplace(root->left);
            if (root->right) s.emplace(root->right);
        }
        reverse(res.begin(), res.end());
        return res;
    }
};
```


```cpp
class Solution {
public:
    vector<int> postorderTraversal(TreeNode* root) {

        vector<int> res;
        TreeNode* curr = root;
        while (curr) {
            TreeNode* left = curr->left;
            if (left) {
                while (left->right && left->right != curr) {
                    left = left->right;
                }
                if (!left->right) {
                    left->right = curr;
                    curr = curr->left;
                    continue;
                }
                left->right = nullptr;
                print(curr->left, res);
            }
            curr = curr->right;
        }
        print(root, res);
        return res;
    }

private:
    void print(TreeNode* root, vector<int>& res) {

        TreeNode* tail = reverse(root);
        TreeNode* curr = tail;
        while (curr) {
            res.emplace_back(curr->val);
            curr = curr->right;
        }
        reverse(tail);
    }

    TreeNode* reverse(TreeNode* root) {
        
        TreeNode* pare = nullptr;
        TreeNode* curr = root;
        while (curr) {
            TreeNode* right = curr->right;
            curr->right = pare;
            pare = curr;
            curr = right;
        }
        return pare;
    }
};
```



### 练习

###### [341. 扁平化嵌套列表迭代器](https://leetcode-cn.com/problems/flatten-nested-list-iterator/)

```cpp
class NestedIterator {
public:
    NestedIterator(vector<NestedInteger> &nestedList) {
        
        for (auto it = nestedList.crbegin(); it != nestedList.crend(); ++it) {
            s.emplace(*it);
        }
    }
    
    int next() {
        
        int res = s.top().getInteger(); s.pop();
        return res;
    }
    
    bool hasNext() {
        
        while (!s.empty() && !s.top().isInteger()) {
            auto n = move(s.top()); s.pop();
            auto l = n.getList();
            for (auto it = l.crbegin(); it != l.crend(); ++it) {
                s.emplace(*it);
            }
        }
        return !s.empty();
    }

private:
    stack<NestedInteger> s;
};
```

```cpp
class NestedIterator {
public:
    NestedIterator(vector<NestedInteger> &nestedList) {
        for (const auto& n : nestedList) {
            dfs(n);
        }
    }
    
    int next() {
        return res[i++];
    }
    
    bool hasNext() {
        return i < res.size();
    }

private:
    int i = 0;
    vector<int> res;

    void dfs(const NestedInteger& n) {
        if (n.isInteger()) {
            res.emplace_back(n.getInteger());
            return;
        }
        const auto& l = n.getList();
        for (const auto& n : l) {
            dfs(n);
        }
    }
};
```




### 例题

###### [102. 二叉树的层序遍历](https://leetcode-cn.com/problems/binary-tree-level-order-traversal/)

```cpp
class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode* root) {

        vector<vector<int>> res;
        queue<TreeNode*> q;
        if (root) q.emplace(root);
        while (!q.empty()) {
            int n = q.size();
            res.emplace_back(vector<int>(n));
            for (int i = 0; i < n; i++) {
                root = q.front(); q.pop();
                res.back()[i] = root->val;
                if (root->left) q.emplace(root->left);
                if (root->right) q.emplace(root->right);
            }
        }
        return res;
    }
};
```

```cpp
class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode* root) {

        vector<vector<int>> res;
        function<void(TreeNode*, int)> dfs = [&](TreeNode* root, int d) {
            if (!root) return;
            if (d == res.size()) res.emplace_back();
            res[d].emplace_back(root->val);
            dfs(root->left, d + 1);
            dfs(root->right, d + 1);
        };
        dfs(root, 0);
        return res;
    }
};
```




### 练习

###### [107. 二叉树的层序遍历 II](https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/)

```cpp
class Solution {
public:
    vector<vector<int>> levelOrderBottom(TreeNode* root) {

        vector<vector<int>> res;
        queue<TreeNode*> q;
        if (root) q.emplace(root);
        while (!q.empty()) {
            int n = q.size();
            res.emplace_back(n);
            for (int i = 0; i < n; i++) {
                root = q.front(); q.pop();
                res.back()[i] = root->val;
                if (root->left) q.emplace(root->left);
                if (root->right) q.emplace(root->right);
            }
        }
        reverse(res.begin(), res.end());
        return res;
    }
};
```

```cpp
class Solution {
public:
    vector<vector<int>> levelOrderBottom(TreeNode* root) {

        vector<vector<int>> res;
        function<void(TreeNode*, int)> dfs = [&](TreeNode* root, int d) {
            if (!root) return;
            if (d == res.size()) res.emplace_back();
            res[d].emplace_back(root->val);
            dfs(root->left, d + 1);
            dfs(root->right, d + 1);
        };
        dfs(root, 0);
        reverse(res.begin(), res.end());
        return res;
    }
};
```



###### [103. 二叉树的锯齿形层序遍历](https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/)

```cpp
class Solution {
public:
    vector<vector<int>> zigzagLevelOrder(TreeNode* root) {

        vector<vector<int>> res;
        deque<TreeNode*> dq;
        if (root) dq.emplace_back(root);
        bool rl = true; // 下层的打印顺序
        while (!dq.empty()) {
            int n = dq.size();
            res.emplace_back(n);
            for (int i = 0; i < n; i++) {
                if (rl) {
                    root = dq.front(); dq.pop_front();
                    res.back()[i] = root->val;
                    if (root->left) dq.emplace_back(root->left);
                    if (root->right) dq.emplace_back(root->right);
                }
                else {
                    root = dq.back(); dq.pop_back();
                    res.back()[i] = root->val;
                    if (root->right) dq.emplace_front(root->right);
                    if (root->left) dq.emplace_front(root->left);
                }
            }
            rl ^= 1;
        }
        return res;
    }
};
```

```cpp
class Solution {
public:
    vector<vector<int>> zigzagLevelOrder(TreeNode* root) {

        vector<vector<int>> res;
        queue<TreeNode*> q;
        if (root) q.emplace(root);
        while (!q.empty()) {
            int n = q.size();
            res.emplace_back(n);
            bool lr = res.size() & 1;	// 当前的打印顺序
            for (int i = 0; i < n; i++) {
                root = q.front(); q.pop();
                res.back()[lr ? i : n - 1 - i] = root->val;
                if (root->left) q.emplace(root->left);
                if (root->right) q.emplace(root->right);
            }
        }
        return res;
    }
};
```




###### [199. 二叉树的右视图](https://leetcode-cn.com/problems/binary-tree-right-side-view/)

```cpp
class Solution {
public:
    vector<int> rightSideView(TreeNode* root) {

        vector<int> res;
        queue<TreeNode*> q;
        if (root) q.emplace(root);
        while (!q.empty()) {
            res.emplace_back(q.back()->val);
            int n = q.size();
            while (n--) {
                root = q.front(); q.pop();
                if (root->left) q.emplace(root->left);
                if (root->right) q.emplace(root->right);
            }
        }
        return res;
    }
};
```

```cpp
class Solution {
public:
    vector<int> rightSideView(TreeNode* root) {

        vector<int> res;
        function<void(TreeNode*, int)> dfs = [&](TreeNode* root, int d) {
            if (!root) return;
            if (d == res.size()) res.emplace_back(root->val);
            dfs(root->right, d + 1);
            dfs(root->left, d + 1);
        };
        dfs(root, 0);
        return res;
    }
};
```




### 例题

###### [279. 完全平方数](https://leetcode-cn.com/problems/perfect-squares/)

```cpp
class Solution {
public:
    int numSquares(int n) {

        vector<int> dp(n + 1, INT_MAX);	// dp[i]：组成整数i的最少完全平方数的个数
        // dp[i] = min{ dp[i-j*j]+1 } 1≤j*j≤i
        dp[0] = 0;
        for (int i = 1; i <= n; i++) {
            for (int j = 1; ; j++) {
                int k = i - j * j;
                if (k < 0) break;
                dp[i] = min(dp[i], dp[k] + 1);
            }
        }
        return dp[n];
    }
};
```

```cpp
class Solution {
public:
    int numSquares(int n) {

        vector<bool> visited(n + 1);
        queue<int> q;
        q.emplace(n);
        visited[n] = true;
        int d = 0;
        while (!q.empty()) {
            d++;
            int sz = q.size();
            while (sz--) {
                int i = q.front(); q.pop();
                for (int j = 1; ; j++) {	// 边
                    int k = i - j * j;	// 邻接点
                    if (k < 0) break;
                    if (k == 0) return d;
                    if (visited[k]) continue;
                    q.emplace(k);
                    visited[k] = true;
                }
            }
        }
        return 0;
    }
};
```


```cpp
class Solution {
public:
    int numSquares(int n) {

        while (n % 4 == 0) n /= 4;

        if (n % 8 == 7) return 4;

        if (isSquare(n)) return 1;
        for (int i = 1; i * i < n; i++) {
            if (isSquare(n - i * i)) return 2;
        }
        return 3;
    }

private:
    bool isSquare(int n) {

        int i = sqrt(n);
        return i * i == n;
    }
};
```




### 练习

###### [127. 单词接龙](https://leetcode-cn.com/problems/word-ladder/)

```cpp
class Solution {
public:
    int ladderLength(string beginWord, string endWord, vector<string>& wordList) {

        unordered_set<string> set(wordList.begin(), wordList.end());
        if (!set.count(endWord)) return 0;

        queue<string> q;
        q.emplace(beginWord);
        set.erase(beginWord);
        int d = 0;
        while (!q.empty()) {
            d++;
            for (int n = q.size(); n > 0; n--) {
                string s = q.front(); q.pop();
                for (char& i : s) {
                    const char c = i;
                    for (char j = 'a'; j <= 'z'; j++) {
                        i = j;
                        if (s == endWord) return d + 1;
                        if (set.count(s)) {
                            q.emplace(s);
                            set.erase(s);
                        }
                    }
                    i = c;
                }
            }
        }
        return 0;
    }
};
```

```cpp
class Solution {
public:
    int ladderLength(string beginWord, string endWord, vector<string>& wordList) {

        unordered_set<string> set(wordList.begin(), wordList.end());
        if (!set.count(endWord)) return 0;

        unordered_set<string> s1{beginWord};
        unordered_set<string> s2{endWord};
        unordered_set<string> tmp;
        int d = 0;
        while (!s1.empty() && !s2.empty()) {
            d++;
            if (s1.size() > s2.size()) s1.swap(s2);
            for (string s : s1) {
                for (char& i : s) {
                    char c = i;
                    for (char j = 'a'; j <= 'z'; j++) {
                        i = j;
                        if (s2.count(s)) return d + 1;
                        if (set.count(s)) {
                            tmp.emplace(s);
                            set.erase(s);
                        }
                    }
                    i = c;
                }
            }
            s1 = move(tmp);
        }
        return 0;
    }
};
```




###### [126. 单词接龙 II](https://leetcode-cn.com/problems/word-ladder-ii/)

```cpp
class Solution {
public:
    vector<vector<string>> findLadders(string beginWord, string endWord, vector<string>& wordList) {

        unordered_set<string> set(wordList.begin(), wordList.end());
        if (!set.count(endWord)) return {};

        unordered_set<string> s1{beginWord}, s2;
        unordered_map<string, vector<string>> childs;
        bool found = false;
        while (!s1.empty() && !found) {
            for (auto& s : s1) set.erase(s);
            for (auto& parent : s1) {
                string child = parent;
                for (auto& i : child) {
                    const char c = i;
                    for (char j = 'a'; j <= 'z'; j++) {
                        i = j;
                        if (child == endWord) {
                            found = true;
                            childs[parent].emplace_back(child);
                        }
                        else if (set.count(child)) {
                            childs[parent].emplace_back(child);
                            s2.emplace(child);
                        }
                    }
                    i = c;
                }
            }
            s1 = move(s2);
        }

        if (!found) return {};

        vector<vector<string>> res;
        vector<string> path{beginWord};
        function<void(const string&)> dfs = [&](auto& parent) {
            if (parent == endWord) {
                res.emplace_back(path);
                return;
            }
            for (auto& child : childs[parent]) {
                path.emplace_back(child);
                dfs(child);
                path.pop_back();
            }
        };
        dfs(beginWord);
        return res;
    }
};
```

```cpp
class Solution {
public:
    vector<vector<string>> findLadders(string beginWord, string endWord, vector<string>& wordList) {

        unordered_set<string> set(wordList.begin(), wordList.end());
        if (!set.count(endWord)) return {};

        unordered_set<string> s1{beginWord};
        unordered_set<string> s2{endWord};
        unordered_set<string> tmp;
        unordered_map<string, vector<string>> childs;
        bool found = false;
        bool back = false;
        while (!s1.empty() && !s2.empty() && !found) {
            if (s1.size() > s2.size()) {
                s1.swap(s2);
                back = !back;
            }
            for (auto& s : s1) set.erase(s);
            for (auto& parent : s1) {
                string child = parent;
                const string* pp = &parent;
                const string* pc = &child;
                if (back) swap(pp, pc);
                for (char& i : child) {
                    const char c = i;
                    for (char j = 'a'; j <= 'z'; j++) {
                        i = j;
                        if (s2.count(child)) {
                            found = true;
                            childs[*pp].emplace_back(*pc);
                        }
                        else if (set.count(child)) {
                            tmp.emplace(child);
                            childs[*pp].emplace_back(*pc);
                        }
                    }
                    i = c;
                }
            }
            s1 = move(tmp);
        }

        if (!found) return {};

        vector<vector<string>> res;
        vector<string> path{beginWord};
        function<void(const string&)> dfs = [&](auto& parent) {
            if (parent == endWord) {
                res.emplace_back(path);
                return;
            }
            for (auto& child : childs[parent]) {
                path.emplace_back(child);
                dfs(child);
                path.pop_back();
            }
        };
        dfs(beginWord);
        return res;
    }
};
```



### 例题

###### [347. 前 K 个高频元素](https://leetcode-cn.com/problems/top-k-frequent-elements/)

```cpp
class Solution {
public:
    vector<int> topKFrequent(vector<int>& nums, int k) {

        unordered_map<int, int> counts;
        for (int n : nums) counts[n]++;

        auto cmp = [&](int a, int b) { return counts[a] > counts[b]; };
        priority_queue<int, vector<int>, decltype(cmp)> pq(cmp);
        for (auto [n, c] : counts) {
            if (pq.size() < k) {
                pq.emplace(n);
            }
            else if (counts[pq.top()] < c) {
                pq.pop();
                pq.emplace(n);
            }
        }

        vector<int> res;
        while (!pq.empty()) {
            res.emplace_back(pq.top()); pq.pop();
        }
        return res;
    }
};
```


```cpp
class Solution {
public:
    vector<int> topKFrequent(vector<int>& nums, int k) {

        unordered_map<int, int> counts;
        for (int n : nums) counts[n]++;

        vector<int> res;
        auto cmp = [&](int a, int b) { return counts[a] < counts[b]; };
        priority_queue<int, vector<int>, decltype(cmp)> pq(cmp);
        int m = counts.size() - k;
        for (auto [n, c] : counts) {
            pq.emplace(n);
            if (pq.size() > m) {
                res.emplace_back(pq.top()); pq.pop();
            }
        }
        return res;
    }
};
```


```cpp
class Solution {
public:
    vector<int> topKFrequent(vector<int>& nums, int k) {

        unordered_map<int, int> counts;
        for (int n : nums) counts[n]++;

        unordered_map<int, vector<int>> buckets;
        int max_count = 0;
        for (auto [n, c] : counts) {
            buckets[c].emplace_back(n);
            max_count = max(max_count, c);
        }

        vector<int> res;
        for (int c = max_count; res.size() < k; c--) {
            auto it = buckets.find(c);
            if (it != buckets.end()) {
                res.insert(res.end(), it->second.begin(), it->second.end());
            }
        }
        return res;
    }
};
```



### 练习

###### [23. 合并K个升序链表](https://leetcode-cn.com/problems/merge-k-sorted-lists/)

```cpp
class Solution {
public:
    ListNode* mergeKLists(vector<ListNode*>& lists) {

        auto cmp = [](auto a, auto b) { return a->val > b->val; };
        priority_queue<ListNode*, vector<ListNode*>, decltype(cmp)> pq(cmp);

        ListNode dummy;
        ListNode* tail = &dummy;
        for (ListNode* head : lists) {
            if (head) pq.emplace(head);
        }
        while (!pq.empty()) {
            tail = tail->next = pq.top(); pq.pop();
            if (tail->next) pq.emplace(tail->next);
        }
        return dummy.next;
    }
};
```

```cpp
class Solution {
public:
    ListNode* mergeKLists(vector<ListNode*>& lists) {

        return merge(lists, 0, lists.size() - 1);
    }

private:
    ListNode* merge(vector<ListNode*>& lists, int l, int r) {

        if (l > r) return nullptr;
        if (l == r) return lists[l];
        int m = l + (r - l) / 2;
        return mergeTwoLists(merge(lists, l, m), merge(lists, m + 1, r));
    }

    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {

        ListNode dummy;
        ListNode* tail = &dummy;
        while (l1 && l2) {
            if (l1->val > l2->val) swap(l1, l2);
            tail = tail->next = l1;
            l1 = l1->next;
        }
        tail->next = l1 ? l1 : l2;
        return dummy.next;
    }
};
```


```cpp
class Solution {
public:
    ListNode* mergeKLists(vector<ListNode*>& lists) {

        if (lists.empty()) return nullptr;

        for (int i = 1; i < lists.size(); i += i) {
            for (int j = 0; j + i < lists.size(); j += i + i) {
                lists[j] = mergeTwoLists(lists[j], lists[j + i]);
            }
        }
        return lists[0];
    }

private:
    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {

        ListNode dummy;
        ListNode* tail = &dummy;
        while (l1 && l2) {
            if (l1->val > l2->val) swap(l1, l2);
            tail = tail->next = l1;
            l1 = l1->next;
        }
        tail->next = l1 ? l1 : l2;
        return dummy.next;
    }
};
```




## Part 7



### 例题

###### [104. 二叉树的最大深度](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/)

```cpp
class Solution {
public:
    int maxDepth(TreeNode* root) {

        if (!root) return 0;
        return max(maxDepth(root->left), maxDepth(root->right)) + 1;
    }
};
```

```cpp
class Solution {
public:
    int maxDepth(TreeNode* root) {

        int res = 0;
        queue<TreeNode*> q;
        if (root) q.emplace(root);
        while (!q.empty()) {
            res++;
            int n = q.size();
            while (n--) {
                root = q.front(); q.pop();
                if (root->left) q.emplace(root->left);
                if (root->right) q.emplace(root->right);
            }
        }
        return res;
    }
};
```




### 练习

###### [111. 二叉树的最小深度](https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/)

```cpp
class Solution {
public:
    int minDepth(TreeNode* root) {

        if (!root) return 0;

        int l = minDepth(root->left);
        int r = minDepth(root->right);
        if (l && r) return min(l, r) + 1;
        return l + r + 1;
    }
};
```

```cpp
class Solution {
public:
    int minDepth(TreeNode* root) {
        
        int res = 0;
        queue<TreeNode*> q;
        if (root) q.emplace(root);
        while (!q.empty()) {
            res++;
            int n = q.size();
            while (n--) {
                root = q.front(); q.pop();
                if (!root->left && !root->right) return res;
                if (root->left) q.emplace(root->left);
                if (root->right) q.emplace(root->right); 
            }
        }
        return res;
    }
};
```




### 例题

###### [226. 翻转二叉树](https://leetcode-cn.com/problems/invert-binary-tree/)

```cpp
class Solution {
public:
    TreeNode* invertTree(TreeNode* root) {

        if (root) {
            invertTree(root->left);
            invertTree(root->right);
            swap(root->left, root->right);
        }
        return root;
    }
};
```

```cpp
class Solution {
public:
    TreeNode* invertTree(TreeNode* root) {

        queue<TreeNode*> q;
        if (root) q.emplace(root);
        while (!q.empty()) {
            TreeNode* curr = q.front(); q.pop();
            swap(curr->left, curr->right);
            if (curr->left) q.emplace(curr->left);
            if (curr->right) q.emplace(curr->right);
        }
        return root;
    }
};
```




### 练习

###### [100. 相同的树](https://leetcode-cn.com/problems/same-tree/)

```cpp
class Solution {
public:
    bool isSameTree(TreeNode* p, TreeNode* q) {

        if (!p && !q) return true;
        if (!p || !q) return false;
        return p->val == q->val && 
            isSameTree(p->left, q->left) &&
            isSameTree(p->right, q->right);
    }
};
```

```cpp
class Solution {
public:
    bool isSameTree(TreeNode* p, TreeNode* q) {

        queue<pair<TreeNode*, TreeNode*>> que;
        que.emplace(p, q);
        while (!que.empty()) {
            tie(p, q) = que.front(); que.pop();
            if (!p && !q) continue;
            if (!p || !q) return false;
            if (p->val != q->val) return false;
            que.emplace(p->left, q->left);
            que.emplace(p->right, q->right);
        }
        return true;
    }
};
```




###### [101. 对称二叉树](https://leetcode-cn.com/problems/symmetric-tree/)

```cpp
class Solution {
public:
    bool isSymmetric(TreeNode* root) {

        if (!root) return true;
        return dfs(root->left, root->right);
    }

private:
    bool dfs(TreeNode* a, TreeNode* b) {

        if (!a && !b) return true;
        if (!a || !b) return false;
        return a->val == b->val &&
            dfs(a->left, b->right) &&
            dfs(a->right, b->left);
    }
};
```

```cpp
class Solution {
public:
    bool isSymmetric(TreeNode* root) {

        queue<pair<TreeNode*, TreeNode*>> q;
        if (root) q.emplace(root->left, root->right);
        while (!q.empty()) {
            auto [a, b] = q.front(); q.pop();
            if (!a && !b) continue;
            if (!a || !b) return false;
            if (a->val != b->val) return false;
            q.emplace(a->left, b->right);
            q.emplace(a->right, b->left);
        }
        return true;
    }
};
```




###### [222. 完全二叉树的节点个数](https://leetcode-cn.com/problems/count-complete-tree-nodes/)

```cpp
class Solution {
public:
    int countNodes(TreeNode* root) {

        return dfs(root, height(root));
    }

private:
    int height(TreeNode* root) {

        int h = 0;
        while (root) {
            h++;
            root = root->left;
        }
        return h;
    }

    int dfs(TreeNode* root, int h) {

        if (!root) return 0;

        if (height(root->right) == h - 1) {
            return (1 << (h - 1)) + dfs(root->right, h - 1);
        }
        return dfs(root->left, h - 1) + (1 << (h - 2));
    }
};
```

```cpp
class Solution {
public:
    int countNodes(TreeNode* root) {

        int res = 0;
        int h = height(root);
        while (root) {
            if (height(root->right) == h - 1) {
                res += 1 << (h - 1);
                root = root->right;
            }
            else {
                res += 1 << (h - 2);
                root = root->left;
            }
            h--;
        }
        return res;
    }

private:
    int height(TreeNode* root) {
        
        int h = 0;
        while (root) {
            h++;
            root = root->left;
        }
        return h;
    }
};
```




###### [110. 平衡二叉树](https://leetcode-cn.com/problems/balanced-binary-tree/)

```cpp
class Solution {
public:
    bool isBalanced(TreeNode* root) {

        return dfs(root) != -1;
    }

private:
    int dfs(TreeNode* root) {

        if (!root) return 0;

        int l = dfs(root->left);
        if (l == -1) return -1;

        int r = dfs(root->right);
        if (r == -1) return -1;

        if (abs(l - r) > 1) return -1;
        return max(l, r) + 1;
    }
};
```



### 例题

###### [112. 路径总和](https://leetcode-cn.com/problems/path-sum/)

```cpp
class Solution {
public:
    bool hasPathSum(TreeNode* root, int targetSum) {

        if (!root) return false;

        targetSum -= root->val;
        if (!root->left && !root->right) return targetSum == 0;
        return hasPathSum(root->left, targetSum) || 
            hasPathSum(root->right, targetSum);
    }
};
```

```cpp
class Solution {
public:
    bool hasPathSum(TreeNode* root, int targetSum) {

        queue<pair<TreeNode*, int>> q;
        if (root) q.emplace(root, targetSum);
        while (!q.empty()) {
            tie(root, targetSum) = q.front(); q.pop();
            targetSum -= root->val;
            if (!root->left && !root->right) {
                if (targetSum == 0) return true;
                continue;
            }
            if (root->left) q.emplace(root->left, targetSum);
            if (root->right) q.emplace(root->right, targetSum);
        }
        return false;
    }
};
```




### 练习

###### [111. 二叉树的最小深度](https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/)

```cpp
// 前面出现过
```



###### [404. 左叶子之和](https://leetcode-cn.com/problems/sum-of-left-leaves/)

```cpp
class Solution {
public:
    int sumOfLeftLeaves(TreeNode* root) {

        if (!root) return 0;

        if (root->left && !root->left->left && !root->left->right) {
            return root->left->val + sumOfLeftLeaves(root->right);
        }
        return sumOfLeftLeaves(root->left) + sumOfLeftLeaves(root->right); 
    }
};
```

```cpp
class Solution {
public:
    int sumOfLeftLeaves(TreeNode* root) {

        int res = 0;
        queue<TreeNode*> q;
        if (root) q.emplace(root);
        while (!q.empty()) {
            root = q.front(); q.pop();
            if (root->left) {
                if (!root->left->left && !root->left->right) {
                    res += root->left->val;
                }
                else q.emplace(root->left);
            }
            if (root->right) q.emplace(root->right);
        }
        return res;
    }
};
```




### 例题

###### [257. 二叉树的所有路径](https://leetcode-cn.com/problems/binary-tree-paths/)

```cpp
class Solution {
public:
    vector<string> binaryTreePaths(TreeNode* root) {

        vector<string> res;
        function<void(TreeNode*, string)> dfs = [&](auto root, auto p) {
            if (!root) return;
            p += to_string(root->val);
            if (!root->left && !root->right) {
                res.emplace_back(p);
                return;
            }
            p += "->";
            dfs(root->left, p);
            dfs(root->right, p);
        };
        dfs(root, "");
        return res;
    }
};
```

```cpp
class Solution {
public:
    vector<string> binaryTreePaths(TreeNode* root) {

        vector<string> res;
        queue<pair<TreeNode*, string>> q;
        if (root) q.emplace(root, "");
        while (!q.empty()) {
            auto [curr, p] = q.front(); q.pop();
            p.append(to_string(curr->val));
            if (!curr->left && !curr->right) {
                res.emplace_back(p);
                continue;
            }
            p.append("->");
            if (curr->left) q.emplace(curr->left, p);
            if (curr->right) q.emplace(curr->right, p);
        }
        return res;
    }
};
```




### 练习

###### [113. 路径总和 II](https://leetcode-cn.com/problems/path-sum-ii/)

```cpp
class Solution {
public:
    vector<vector<int>> pathSum(TreeNode* root, int targetSum) {

        vector<vector<int>> res;
        vector<int> p;
        function<void(TreeNode*, int)> dfs = [&](TreeNode* root, int targetSum) {
            if (!root) return;
            p.emplace_back(root->val);
            targetSum -= root->val;
            if (!root->left && !root->right && !targetSum) {
                res.emplace_back(p);
            }
            dfs(root->left, targetSum);
            dfs(root->right, targetSum);
            p.pop_back();
        };
        dfs(root, targetSum);
        return res;
    }
};
```

```cpp
class Solution {
public:
    vector<vector<int>> pathSum(TreeNode* root, int targetSum) {

        vector<vector<int>> res;
        unordered_map<TreeNode*, TreeNode*> parents;
        queue<pair<TreeNode*, int>> q;
        if (root) q.emplace(root, targetSum);
        while (!q.empty()) {
            tie(root, targetSum) = q.front(); q.pop();
            targetSum -= root->val;
            if (!root->left && !root->right) {
                if (targetSum == 0) {
                    vector<int> p;
                    while (root) {
                        p.emplace_back(root->val);
                        root = parents[root];
                    }
                    reverse(p.begin(), p.end());
                    res.emplace_back(move(p));
                }
                continue;
            }
            if (root->left) {
                parents[root->left] = root;
                q.emplace(root->left, targetSum);
            }
            if (root->right) {
                parents[root->right] = root;
                q.emplace(root->right, targetSum);
            }
        }
        return res;
    }
};
```




###### [129. 求根节点到叶节点数字之和](https://leetcode-cn.com/problems/sum-root-to-leaf-numbers/)

```cpp
class Solution {
public:
    int sumNumbers(TreeNode* root) {

        int res = 0;
        function<void(TreeNode*, int)> dfs = [&](TreeNode* root, int n) {
            if (!root) return;
            n = n * 10 + root->val;
            if (!root->left && !root->right) {
                res += n;
                return;
            }
            dfs(root->left, n);
            dfs(root->right, n);
        };
        dfs(root, 0);
        return res;
    }
};
```

```cpp
class Solution {
public:
    int sumNumbers(TreeNode* root) {

        int res = 0;
        queue<pair<TreeNode*, int>> q;
        if (root) q.emplace(root, 0);
        while (!q.empty()) {
            auto [curr, n] = q.front(); q.pop();
            n = n * 10 + curr->val;
            if (!curr->left && !curr->right) {
                res += n;
                continue;
            }
            if (curr->left) q.emplace(curr->left, n);
            if (curr->right) q.emplace(curr->right, n);
        }
        return res;
    }
};
```




### 例题

###### [437. 路径总和 III](https://leetcode-cn.com/problems/path-sum-iii/)

```cpp
class Solution {
public:
    int pathSum(TreeNode* root, int sum) {

        if (!root) return 0;
        return dfs(root, sum) +
            pathSum(root->left, sum) +
            pathSum(root->right, sum);
    }

private:
    int dfs(TreeNode* root, int sum) {

        if (!root) return 0;
        sum -= root->val;
        return (sum == 0) +
            dfs(root->left, sum) +
            dfs(root->right, sum);
    }
};
```

```cpp
class Solution {
public:
    int pathSum(TreeNode* root, int sum) {

        int res = 0;
        unordered_map<int, int> counts;	// counts[pre]：前缀和pre出现的次数
        counts[0] = 1;
        function<void(TreeNode*, int)> dfs = [&](TreeNode* root, int pre) {
            if (!root) return;
            pre += root->val;
            res += counts[pre - sum];
            counts[pre]++;
            dfs(root->left, pre);
            dfs(root->right, pre);
            counts[pre]--;
        };
        dfs(root, 0);
        return res;
    }
};
```




### 练习



### 例题

###### [235. 二叉搜索树的最近公共祖先](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/)

```cpp
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {

        if (p->val > q->val) swap(p, q);
        if (p->val > root->val) return lowestCommonAncestor(root->right, p, q);
        if (q->val < root->val) return lowestCommonAncestor(root->left, p, q);
        return root;   
    }
};
```

```cpp
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        
        while (root) {
            if (p->val > q->val) swap(p, q);
            if (p->val > root->val) root = root->right;
            else if (q->val < root->val) root = root->left;
            else return root;
        }
        return root;
    }
};
```




### 练习

###### [98. 验证二叉搜索树](https://leetcode-cn.com/problems/validate-binary-search-tree/)

```cpp
class Solution {
public:
    bool isValidBST(TreeNode* root) {

        return dfs(root, nullptr, nullptr);
    }

private:
    bool dfs(TreeNode* root, TreeNode* left, TreeNode* right) {
        
        if (!root) return true;

        if (left && left->val >= root->val) return false;
        if (right && right->val <= root->val) return false;
        return dfs(root->left, left, root) && dfs(root->right, root, right);
    }
};
```

```cpp
class Solution {
public:
    bool isValidBST(TreeNode* root) {

        TreeNode* pre = nullptr;
        function<bool(TreeNode*)> dfs = [&](auto root) {
            if (!root) return true;
            if (!dfs(root->left)) return false;
            if (pre && pre->val >= root->val) return false;
            pre = root;
            return dfs(root->right);
        };
        return dfs(root);
    }
};
```


```cpp
class Solution {
public:
    bool isValidBST(TreeNode* root) {

        TreeNode* pre = nullptr;
        stack<TreeNode*> ;
        while (root || !s.empty()) {
            if (root) {
                s.emplace(root);
                root = root->left;
            }
            else {
                root = s.top(); s.pop();
                if (pre && pre->val >= root->val) return false;
                pre = root;
                root = root->right;
            }
        }
        return true;
    }
};
```


```cpp
class Solution {
public:
    bool isValidBST(TreeNode* root) {
        
        bool res = true;
        TreeNode* pre = nullptr;
        while (root) {
            TreeNode* left = root->left;
            if (left) {
                while (left->right && left->right != root) {
                    left = left->right;
                }
                if (!left->right) {
                    left->right = root;
                    root = root->left;
                    continue;
                }
                left->right = nullptr;
            }
            if (pre && pre->val >= root->val) res = false;
            pre = root;
            root = root->right;
        }
        return res;
    }
};
```




###### [450. 删除二叉搜索树中的节点](https://leetcode-cn.com/problems/delete-node-in-a-bst/)

```cpp
class Solution {
public:
    TreeNode* deleteNode(TreeNode* root, int key) {
        
        if (!root) return nullptr;

        if (key < root->val) {
            root->left = deleteNode(root->left, key);
            return root;
        }
        if (key > root->val) {
            root->right = deleteNode(root->right, key);
            return root;
        }
        if (!root->left || !root->right) {
            TreeNode* newRoot = root->left ? root->left : root->right;
            delete root;
            return newRoot;
        }
        TreeNode* next = root->right;
        while (next->left) next = next->left;
        root->val = next->val;
        root->right = deleteNode(root->right, next->val);
        return root;
    }
};
```

```cpp
class Solution {
public:
    TreeNode* deleteNode(TreeNode* root, int key) {
        
        if (!root) return nullptr;

        if (key < root->val) {
            root->left = deleteNode(root->left, key);
            return root;
        }
        if (key > root->val) {
            root->right = deleteNode(root->right, key);
            return root;
        }
        if (!root->left || !root->right) {
            TreeNode* newRoot = root->left ? root->left : root->right;
            delete root;
            return newRoot;
        }
        TreeNode* next = root->right;
        while (next->left) next = next->left;
        next->left = root->left;
        next = root->right;
        delete root;
        return next;
    }
};
```

```cpp
class Solution {
public:
    TreeNode* deleteNode(TreeNode* root, int key) {
        
        if (!root) return nullptr;

        if (key < root->val) {
            root->left = deleteNode(root->left, key);
            return root;
        }
        if (key > root->val) {
            root->right = deleteNode(root->right, key);
            return root;
        }
        if (!root->left || !root->right) {
            TreeNode* newRoot = root->left ? root->left : root->right;
            delete root;
            return newRoot;
        }
        TreeNode* parent = root;
        TreeNode* child = root->right;
        while (child->left) {
            parent = child;
            child = child->left;
        }
        child->left = root->left;
        if (parent != root) {
            parent->left = child->right;
            child->right = root->right;
        }
        delete root;
        return child;
    }
};
```


```cpp
class Solution {
public:
    TreeNode* deleteNode(TreeNode* root, int key) {
        
        TreeNode* pare = nullptr;
        TreeNode* curr = root;
        while (curr) {
            if (curr->val == key) break;
            pare = curr;
            if (key < curr->val) curr = curr->left;
            else curr = curr->right;
        }
        if (!curr) return root;
        if (!pare) return deleteNode(root);
        if (key < pare->val) pare->left = deleteNode(curr);
        else pare->right = deleteNode(curr);
        return root;
    }

private:
    TreeNode* deleteNode(TreeNode* root) {
        
        if (!root->left || !root->right) {
            TreeNode* newRoot = root->left ? root->left : root->right;
            delete root;
            return newRoot;
        }
        TreeNode* pare = root;
        TreeNode* child = root->right;
        while (child->left) {
            pare = child;
            child = child->left;
        }
        child->left = root->left;
        if (pare != root) {
            pare->left = child->right;
            child->right = root->right;
        }
        delete root;
        return child;
    }
};
```

```cpp
class Solution {
public:
    TreeNode* deleteNode(TreeNode* root, int key) {
        
        TreeNode* pare = nullptr;
        TreeNode* curr = root;
        while (curr) {
            if (curr->val == key) break;
            pare = curr;
            if (key < curr->val) curr = curr->left;
            else curr = curr->right;
        }
        if (!curr) return root;
        if (!pare) return deleteNode(root);
        if (key < pare->val) pare->left = deleteNode(curr);
        else pare->right = deleteNode(curr);
        return root;
    }

private:
    TreeNode* deleteNode(TreeNode* root) {
        
        if (!root->left || !root->right) {
            TreeNode* newRoot = root->left ? root->left : root->right;
            delete root;
            return newRoot;
        }
        TreeNode* next = root->right;
        while (next->left) next = next->left;
        next->left = root->left;
        next = root->right;
        delete root;
        return next;
    }
};
```



###### [108. 将有序数组转换为二叉搜索树](https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/)

```cpp
class Solution {
public:
    TreeNode* sortedArrayToBST(vector<int>& nums) {

        function<TreeNode*(int, int)> dfs = 
            [&](int l, int r) -> TreeNode* {
                if (l > r) return nullptr;
                int m = l + (r - l) / 2;
                TreeNode* root = new TreeNode(nums[m]);
                root->left = dfs(l, m - 1);
                root->right = dfs(m + 1, r);
                return root;
        };
        return dfs(0, nums.size() - 1);
    }
};
```



###### [230. 二叉搜索树中第K小的元素](https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst/)

```cpp
class Solution {
public:
    int kthSmallest(TreeNode* root, int k) {

        int res = INT_MAX;
        function<void(TreeNode*)> dfs = [&](auto root) {
            if (!root) return;
            dfs(root->left);
            if (k < 1) return;
            if (k-- == 1) res = root->val;
            else dfs(root->right);
        };
        dfs(root);
        return res;
    }
};
```

```cpp
class Solution {
public:
    int kthSmallest(TreeNode* root, int k) {

        stack<TreeNode*> s;
        while (root || !s.empty()) {
            if (root) {
                s.emplace(root);
                root = root->left;
            }
            else {
                root = s.top(); s.pop();
                if (k-- == 1) return root->val;
                root = root->right;
            }
        }
        return -1;
    }
};
```


```cpp
class Solution {
public:
    int kthSmallest(TreeNode* root, int k) {

        int res = INT_MAX;
        while (root) {
            TreeNode* left = root->left;
            if (left) {
                while (left->right && left->right != root) {
                    left = left->right;
                }
                if (!left->right) {
                    left->right = root;
                    root = root->left;
                    continue;
                }
                left->right = nullptr;
            }
            if (k-- == 1) res = root->val;
            root = root->right;
        }
        return res;
    }
};
```



###### [236. 二叉树的最近公共祖先](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/)

```cpp
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        
        vector<TreeNode*> pp, pq, path;
        function<void(TreeNode*)> dfs = [&](auto root) {
            if (!root || !pp.empty() && !pq.empty()) return;
            path.emplace_back(root);
            if (root == p) pp = path;
            else if (root == q) pq = path;
            dfs(root->left);
            dfs(root->right);
            path.pop_back();
        };
        dfs(root);
        int i = 0;
        while (i < pp.size() && i < pq.size() && pp[i] == pq[i]) i++;
        return pp[i - 1];
    }
};
```

```cpp
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        
        if (!root || root == p || root == q) return root;

        TreeNode* l = lowestCommonAncestor(root->left, p, q);
        TreeNode* r = lowestCommonAncestor(root->right, p, q);
        if (!l) return r;
        if (!r) return l;
        return root;
    }
};
```

```cpp
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        
        queue<TreeNode*> que;
        unordered_map<TreeNode*, TreeNode*> parents;
        if (root) que.emplace(root);
        parents[root] = nullptr;
        while (!parents.count(p) || !parents.count(q)) {
            root = que.front(); que.pop();
            if (root->left) {
                que.emplace(root->left);
                parents[root->left] = root;
            }
            if (root->right) {
                que.emplace(root->right);
                parents[root->right] = root;
            }
        }
        unordered_set<TreeNode*> set;
        while (p) {
            set.emplace(p);
            p = parents[p];
        }
        while (!set.count(q)) {
            q = parents[q];
        }
        return q;
    }
};
```



## Part 8



### 例题

###### [17. 电话号码的字母组合](https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/)

```cpp
class Solution {
public:
    vector<string> letterCombinations(string digits) {

        if (digits.empty()) return {};

        vector<string> map{"", "", "abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv", "wxyz"};

        vector<string> res;
        string s(digits.size(), ' ');
        function<void(int)> dfs = [&](int i) {
            // 已经生成字符串s[0,i)，将要查看位置i的字符
            if (i == digits.size()) {
                res.emplace_back(s);
                return;
            }
            string& chars = map[digits[i] - '0'];
            for (char c : chars) {
                s[i] = c;
                dfs(i + 1);
            }
        };
        dfs(0);
        return res;
    }
};
```

```cpp
class Solution {
public:
    vector<string> letterCombinations(string digits) {

        if (digits.empty()) return {};

        vector<string> map{"", "", "abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv", "wxyz"};
        
        vector<string> res{{}};
        vector<string> tmp;
        for (char d : digits) {
            const string& chars = map[d - '0'];
            for (char c : chars) {
                for (const string& s : res) {
                    tmp.emplace_back(s + c);
                }
            }
            res = move(tmp);
        }
        return res;
    }
};
```




### 练习

###### [93. 复原 IP 地址](https://leetcode-cn.com/problems/restore-ip-addresses/)

```cpp
class Solution {
public:
    vector<string> restoreIpAddresses(string s) {

        const int n = s.size();
        vector<string> res;
        function<void(int, int, string)> dfs = [&](int i, int j, string p) {
            // 已经生成字符串p，将要从位置i开始，匹配j个整数
            if (i == n && j == 0) {
                p.pop_back();
                res.emplace_back(move(p));
                return;
            }
            if (i == n || j == 0) return;
            if (n - i < j || n - i > j * 3) return;
            int num = 0;
            for (int l = 1; l <= 3; l++) {
                if (i + l - 1 > n) break;
                if (l > 1 && num == 0) continue;
                num = num * 10 + s[i + l - 1] - '0';
                if (num > 255) break;
                dfs(i + l, j - 1, p + s.substr(i, l) + ".");
            }
        };
        dfs(0, 4, "");
        return res;
    }
};
```



###### [131. 分割回文串](https://leetcode-cn.com/problems/palindrome-partitioning/)

```cpp
class Solution {
public:
    vector<vector<string>> partition(string s) {

        const int n = s.size();
        vector<vector<bool>> valid(n, vector<bool>(n));
        for (int i = 0; i < n; i++) {
            int l = i, r = i;
            while (l >= 0 && r < n && s[l] == s[r]) {
                valid[l--][r++] = true;
            }
            l = i, r = i + 1;
            while (l >= 0 && r < n && s[l] == s[r]) {
                valid[l--][r++] = true;
            }
        }
        vector<vector<string>> res;
        vector<string> c;
        function<void(int)> dfs = [&](int i) {
            // c存放已经得到的子串集合，从位置i开始寻找新的子串
            if (i == n) {
                res.emplace_back(c);
                return;
            }
            for (int j = i; j < n; j++) {
                if (valid[i][j]) {
                    c.emplace_back(s.substr(i, j - i + 1));
                    dfs(j + 1);
                    c.pop_back();
                }
            }
        };
        dfs(0);
        return res;
    }
};
```



### 例题

###### [46. 全排列](https://leetcode-cn.com/problems/permutations/)

```cpp
class Solution {
public:
    vector<vector<int>> permute(vector<int>& nums) {

        const int n = nums.size();
        vector<vector<int>> res;
        vector<int> p(n);
        vector<bool> used(n);
        function<void(int)> dfs = [&](int i) {
            // 已经生成排列[0,i)，将要在位置i放置数字
            if (i == n) {
                res.emplace_back(p);
                return;
            }
            for (int j = 0; j < n; j++) {
                if (used[j]) continue;
                p[i] = nums[j];
                used[j] = true;
                dfs(i + 1);
                used[j] = false;
            }
        };
        dfs(0);
        return res;
    }
};
```

```cpp
class Solution {
public:
    vector<vector<int>> permute(vector<int>& nums) {

        const int n = nums.size();
        vector<vector<int>> res;
        function<void(int)> dfs = [&](int i) {
            // 已经生成排列[0,i)，将要在位置i放置数字
            if (i == n - 1) {
                res.emplace_back(nums);
                return;
            }
            for (int j = i; j < n; j++) {
                swap(nums[i], nums[j]);
                dfs(i + 1);
                swap(nums[i], nums[j]);
            }
        };
        dfs(0);
        return res;
    }
};
```




### 练习

###### [47. 全排列 II](https://leetcode-cn.com/problems/permutations-ii/)

```cpp
class Solution {
public:
    vector<vector<int>> permuteUnique(vector<int>& nums) {

        const int n = nums.size();
        sort(nums.begin(), nums.end());
        vector<vector<int>> res;
        vector<int> p(n);
        vector<bool> used(n);
        function<void(int)> dfs = [&](int i) {
            // 已经生成排列[0,i)，将要在位置i放置数字
            if (i == n) {
                res.emplace_back(p);
                return;
            }
            for (int j = 0; j < n; j++) {
                if (used[j]) continue;
                if (j > 0 && nums[j] == nums[j - 1] && !used[j - 1]) continue;
                p[i] = nums[j];
                used[j] = true;
                dfs(i + 1);
                used[j] = false;
            }
        };
        dfs(0);
        return res;
    }
};
```

```cpp
class Solution {
public:
    vector<vector<int>> permuteUnique(vector<int>& nums) {

        const int n = nums.size();
        vector<vector<int>> res;
        function<void(int)> dfs = [&](int i) {
            // 已经生成排列[0,i)，将要在位置i放置数字
            if (i == n - 1) {
                res.emplace_back(nums);
                return;
            }
            for (int j = i; j < n; j++) {
                auto it = find(nums.begin() + i, nums.begin() + j, nums[j]);
                if (it != nums.begin() + j) continue;
                swap(nums[i], nums[j]);
                dfs(i + 1);
                swap(nums[i], nums[j]);
            }
        };
        dfs(0);
        return res;
    }
};
```




### 例题

###### [77. 组合](https://leetcode-cn.com/problems/combinations/)

```cpp
class Solution {
public:
    vector<vector<int>> combine(int n, int k) {

        vector<vector<int>> res;
        vector<int> c(k);
        function<void(int, int)> dfs = [&](int i, int j) {
            // 已经生成组合[0,i)，将要在位置i放置[j,n]中的数字
            if (i == k) {
                res.emplace_back(c);
                return;
            }
            int max = n + 1 - (k - i);
            for (int m = j; m <= max; m++) {
                c[i] = m;
                dfs(i + 1, m + 1);
            }
        };
        dfs(0, 1);
        return res;
    }
};
```

```cpp
class Solution {
public:
    vector<vector<int>> combine(int n, int k) {

        vector<vector<int>> res;
        vector<int> c(k + 1);
        iota(c.begin(), c.end(), 1);
        c.back() = n + 1;

        int i = 0;
        while (i < k) {
            res.emplace_back(c.begin(), c.begin() + k);
            i = 0;
            while (i < k && c[i] + 1 == c[i + 1]) {
                c[i] = i + 1;
                i++;
            }
            c[i]++;
        }
        return res;
    }
};
```




### 练习

###### [39. 组合总和](https://leetcode-cn.com/problems/combination-sum/)

```cpp
class Solution {
public:
    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {

        sort(candidates.rbegin(), candidates.rend());
        vector<vector<int>> res;
        vector<int> c;
        function<void(int, int)> dfs = [&](int i, int target) {
            // 已经生成组合c，将要在位置i放置[j,n]中的数字
            if (target == 0) {
                res.emplace_back(c);
                return;
            }
            if (target < 0) return;
            for (int j = i; j < candidates.size(); j++) {
                c.emplace_back(candidates[j]);
                dfs(j, target - candidates[j]);
                c.pop_back();
            }
        };
        dfs(0, target);
        return res;
    }
};
```



###### [40. 组合总和 II](https://leetcode-cn.com/problems/combination-sum-ii/)

```cpp
class Solution {
public:
    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {

        sort(candidates.begin(), candidates.end());
        vector<vector<int>> res;
        vector<int> c;
        function<void(int, int)> dfs = [&](int i, int target) {
            // 已经生成组合c，将要在位置i放置[j,n]中的数字
            if (target == 0) {
                res.emplace_back(c);
                return;
            }
            for (int j = i; j < candidates.size(); j++) {
                if (j > i && candidates[j] == candidates[j - 1]) continue;
                if (candidates[j] > target) break;
                c.emplace_back(candidates[j]);
                dfs(j + 1, target - candidates[j]);
                c.pop_back();
            }
        };
        dfs(0, target);
        return res;
    }
};
```




###### [216. 组合总和 III](https://leetcode-cn.com/problems/combination-sum-iii/)

```cpp
class Solution {
public:
    vector<vector<int>> combinationSum3(int k, int n) {

        vector<vector<int>> res;
        vector<int> c(k);
        function<void(int, int, int)> dfs = [&](int i, int j, int n) {
            // 已经生成组合[0,i)，将要在位置i放置[j,9]中的数字
            if (i == k && n == 0) {
                res.emplace_back(c);
                return;
            }
            if (i == k || n <= 0) return;
            for (int m = j; m <= 9; m++) {
                c[i] = m;
                dfs(i + 1, m + 1, n - m);
            }
        };
        dfs(0, 1, n);
        return res;
    }
};
```

```cpp
class Solution {
public:
    vector<vector<int>> combinationSum3(int k, int n) {

        vector<vector<int>> res;
        for (int i = 0; i < (1 << 9); i++) {
            vector<int> c;
            int sum = 0;
            for (int j = 1; j <= 9; j++) {
                if (10 - j < k - c.size()) break;
                if (i & (1 << (j - 1))) {
                    c.emplace_back(j);
                    sum += j;
                    if (sum > n || c.size() > k) break;
                }
            }
            if (c.size() == k && sum == n) {
                res.emplace_back(c);
            }
        }
        return res;
    }
};
```




###### [78. 子集](https://leetcode-cn.com/problems/subsets/)

```cpp
class Solution {
public:
    vector<vector<int>> subsets(vector<int>& nums) {

        vector<vector<int>> res;
        vector<int> c;
        function<void(int)> dfs = [&](int i) {
            // 已经生成组合c，将要在最后添加[i,n)中的数字
            res.emplace_back(c);
            for (int j = i; j < nums.size(); j++) {
                c.emplace_back(nums[j]);
                dfs(j + 1);
                c.pop_back();
            }
        };
        dfs(0);
        return res;
    }
};
```

```cpp
class Solution {
public:
    vector<vector<int>> subsets(vector<int>& nums) {

        const int n = nums.size();
        vector<vector<int>> res;
        for (int i = 0; i < (1 << n); i++) {
            vector<int> c;
            for (int j = 0; j < n; j++) {
                if (i & (1 << j)) c.emplace_back(nums[j]);
            }
            res.emplace_back(c);
        }
        return res;
    }
};
```




###### [90. 子集 II](https://leetcode-cn.com/problems/subsets-ii/)

```cpp
class Solution {
public:
    vector<vector<int>> subsetsWithDup(vector<int>& nums) {

        sort(nums.begin(), nums.end());
        vector<vector<int>> res;
        vector<int> c;
        function<void(int)> dfs = [&](int i) {
            // 已经生成组合c，将要在最后添加[i,n)中的数字
            res.emplace_back(c);
            for (int j = i; j < nums.size(); j++) {
                if (j > i && nums[j] == nums[j - 1]) continue;
                c.emplace_back(nums[j]);
                dfs(j + 1);
                c.pop_back();
            }
        };
        dfs(0);
        return res;
    }
};
```

```cpp
class Solution {
public:
    vector<vector<int>> subsetsWithDup(vector<int>& nums) {

        const int n = nums.size();
        sort(nums.begin(), nums.end());
        vector<vector<int>> res;
        for (int i = 0; i < (1 << n); i++) {
            vector<int> c;
            bool valid = true;
            for (int j = 0; j < n; j++) {
                if (i & (1 << j)) {
                    if (j > 0 && nums[j] == nums[j - 1] && !(i & (1 << (j - 1)))) {
                        valid = false;
                        break;
                    }
                    c.emplace_back(nums[j]);
                }
            }
            if (valid) res.emplace_back(c);
        }
        return res;
    }
};
```




###### [401. 二进制手表](https://leetcode-cn.com/problems/binary-watch/)

```cpp
class Solution {
public:
    vector<string> readBinaryWatch(int num) {

        vector<string> res;
        const int t[]{1, 2, 4, 8, 1, 2, 4, 8, 16, 32};
        function<void(int, int, int, int)> dfs = [&](int num, int i, int h, int m) {
            // 已经获得小时h和分钟m，剩余灯num，从位置i开始
            if (num == 0) {
                res.emplace_back(to_string(h) + (m < 10 ? ":0" : ":") + to_string(m));
                return;
            }
            for (int j = i; j < 10; j++) {
                if (j < 4 && h + t[j] < 12) dfs(num - 1, j + 1, h + t[j], m);
                if (j >= 4 && m + t[j] < 60) dfs(num - 1, j + 1, h, m + t[j]);
            }
        };
        dfs(num, 0, 0, 0);
        return res;
    }
};
```

```cpp
class Solution {
public:
    vector<string> readBinaryWatch(int turnedOn) {

        vector<string> res;
        for (int i = 0; i < 12; i++) {
            for (int j = 0; j < 60; j++) {
                if (__builtin_popcount(i) + __builtin_popcount(j) == turnedOn) {
                    res.emplace_back(to_string(i) + (j < 10 ? ":0" : ":") + to_string(j));
                }
            }
        }
        return res;
    }
};
```




### 例题

###### [79. 单词搜索](https://leetcode-cn.com/problems/word-search/)

```cpp
class Solution {
public:
    bool exist(vector<vector<char>>& board, string word) {

        const int m = board.size();
        const int n = board[0].size();
        const int d[]{0, -1, 0, 1, 0};
        function<bool(int, int, int)> dfs = [&](int i, int j, int k) {
            // 将要查看字符board[i][j]和word[k]
            if (k == word.size()) return true;
            if (i < 0 || i >= m || j < 0 || j >= n) return false;
            if (board[i][j] != word[k]) return false;
            board[i][j] = '#';
            for (int l = 0; l < 4; l++) {
                if (dfs(i + d[l], j + d[l + 1], k + 1)) return true;
            }
            board[i][j] = word[k];
            return false;
        };
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (dfs(i, j, 0)) return true;
            }
        }
        return false;
    }
};
```



### 练习



### 例题

###### [200. 岛屿数量](https://leetcode-cn.com/problems/number-of-islands/)

```cpp
class Solution {
public:
    int numIslands(vector<vector<char>>& grid) {

        const int m = grid.size();
        const int n = grid[0].size();
        const int d[]{0, -1, 0, 1, 0};
        function<void(int i, int j)> dfs = [&](int i, int j) {
            // 将要查看位置(i,j)
            if (i < 0 || i >= m || j < 0 || j >= n) return;
            if (grid[i][j] == '0') return;
            grid[i][j] = '0';
            for (int k = 0; k < 4; k++) {
                dfs(i + d[k], j + d[k + 1]);
            }
        };
        int res = 0;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (grid[i][j] == '1') {
                    res++;
                    dfs(i, j);
                }
            }
        }
        return res;
    }
};
```

```cpp
class Solution {
public:
    int numIslands(vector<vector<char>>& grid) {

        const int m = grid.size();
        const int n = grid[0].size();
        const int d[]{0, -1, 0, 1, 0};
        queue<pair<int, int>> q;
        auto bfs = [&](int i, int j) {
            // 将要查看位置(i,j)
            q.emplace(i, j);
            while (!q.empty()) {
                tie(i, j) = q.front(); q.pop();
                if (i < 0 || i >= m || j < 0 || j >= n) continue;
                if (grid[i][j] == '0') continue;
                grid[i][j] = '0';
                for (int k = 0; k < 4; k++) {
                    q.emplace(i + d[k], j + d[k + 1]);
                }
            }
        };
        int res = 0;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (grid[i][j] == '1') {
                    res++;
                    bfs(i, j);
                }
            }
        }
        return res;
    }
};
```




### 练习

###### [130. 被围绕的区域](https://leetcode-cn.com/problems/surrounded-regions/)

```cpp
class Solution {
public:
    void solve(vector<vector<char>>& board) {

        const int m = board.size();
        const int n = board[0].size();
        const int d[]{0, -1, 0, 1, 0};
        function<void(int, int)> dfs = [&](int i, int j) {
            // 将要查看位置(i,j)
            if (i < 0 || i >= m || j < 0 || j >= n) return;
            if (board[i][j] != 'O') return;
            board[i][j] = 'G';
            for (int k = 0; k < 4; k++) {
                dfs(i + d[k], j + d[k + 1]);
            }
        };
        for (int j = 0; j < n; j++) {
            dfs(0, j), dfs(m - 1, j);
        }
        for (int i = 0; i < m; i++) {
            dfs(i, 0), dfs(i, n - 1);
        }
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (board[i][j] == 'O') board[i][j] = 'X';
                else if (board[i][j] == 'G') board[i][j] = 'O';
            }
        }
    }
};
```

```cpp
class Solution {
public:
    void solve(vector<vector<char>>& board) {

        const int m = board.size();
        const int n = board[0].size();
        const int d[]{0, -1, 0, 1, 0};
        queue<pair<int, int>> q;
        auto bfs = [&](int i, int j) {
            // 将要查看位置(i,j)
            q.emplace(i, j);
            while (!q.empty()) {
                tie(i, j) = q.front(); q.pop();
                if (i < 0 || i >= m || j < 0 || j >= n) continue;
                if (board[i][j] != 'O') continue;
                board[i][j] = 'G';
                for (int k = 0; k < 4; k++) {
                    q.emplace(i + d[k], j + d[k + 1]);
                }
            }
        };
        for (int j = 0; j < n; j++) {
            bfs(0, j), bfs(m - 1, j);
        }
        for (int i = 0; i < m; i++) {
            bfs(i, 0), bfs(i, n - 1);
        }
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (board[i][j] == 'O') board[i][j] = 'X';
                else if (board[i][j] == 'G') board[i][j] = 'O';
            }
        }
    }
};
```




###### [417. 太平洋大西洋水流问题](https://leetcode-cn.com/problems/pacific-atlantic-water-flow/)

```cpp
class Solution {
public:
    vector<vector<int>> pacificAtlantic(vector<vector<int>>& heights) {

        const int m = heights.size();
        if (m == 0) return {};
        const int n = heights[0].size();
        const int d[]{0, 1, 0, -1, 0};
        
        vector<vector<int>> v(m, vector<int>(n));
        // 0：未访问，1：从太平洋已访问，2：从大西洋已访问
        function<void(int, int, int)> dfs1 = [&](int i, int j, int h) {
            // 上个格子的高度为h，将要查看位置(i,j)
            if (i < 0 || i >= m || j < 0 || j >= n) return;
            if (v[i][j] == 1 || heights[i][j] < h) return;
            v[i][j] = 1;
            for (int k = 0; k < 4; k++) {
                dfs1(i + d[k], j + d[k + 1], heights[i][j]);
            }
        };
        for (int i = 0; i < m; i++) dfs1(i, 0, INT_MIN);
        for (int j = 0; j < n; j++) dfs1(0, j, INT_MIN);

        vector<vector<int>> res;
        function<void(int, int, int)> dfs2 = [&](int i, int j, int h) {
            // 上个格子的高度为h，将要查看位置(i,j)
            if (i < 0 || i >= m || j < 0 || j >= n) return;
            if (v[i][j] == 2 || heights[i][j] < h) return;
            if (v[i][j] == 1) res.push_back({i, j});
            v[i][j] = 2;
            for (int k = 0; k < 4; k++) {
                dfs2(i + d[k], j + d[k + 1], heights[i][j]);
            }
        };
        for (int i = 0; i < m; i++) dfs2(i, n - 1, INT_MIN);
        for (int j = 0; j < n; j++) dfs2(m - 1, j, INT_MIN);

        return res;
    }
};
```

```cpp
class Solution {
public:
    vector<vector<int>> pacificAtlantic(vector<vector<int>>& heights) {

        const int m = heights.size();
        if (m == 0) return {};
        const int n = heights[0].size();
        const int d[]{0, 1, 0, -1, 0};
        
        vector<vector<int>> v(m, vector<int>(n));
        // 0：未访问，1：从太平洋已访问，2：从大西洋已访问
        queue<pair<int, int>> q;
        auto bfs1 = [&](int i, int j) {
            // 将要查看位置(i,j)
            q.emplace(i, j);
            v[i][j] = 1;
            while (!q.empty()) {
                tie(i, j) = q.front(); q.pop();
                for (int k = 0; k < 4; k++) {
                    int x = i + d[k];
                    int y = j + d[k + 1];
                    if (x < 0 || x >= m || y < 0 || y >= n) continue;
                    if (v[x][y] == 1 || heights[x][y] < heights[i][j]) continue;
                    q.emplace(x, y);
                    v[x][y] = 1;
                }
            }
        };
        for (int i = 0; i < m; i++) bfs1(i, 0);
        for (int j = 0; j < n; j++) bfs1(0, j);

        vector<vector<int>> res;
        auto bfs2 = [&](int i, int j) {
            // 将要查看位置(i,j)
            if (v[i][j] == 1) res.push_back({i, j});
            q.emplace(i, j);
            v[i][j] = 2;
            while (!q.empty()) {
                tie(i, j) = q.front(); q.pop();
                for (int k = 0; k < 4; k++) {
                    int x = i + d[k];
                    int y = j + d[k + 1];
                    if (x < 0 || x >= m || y < 0 || y >= n) continue;
                    if (v[x][y] == 2 || heights[x][y] < heights[i][j]) continue;
                    if (v[x][y] == 1) res.push_back({x, y});
                    q.emplace(x, y);
                    v[x][y] = 2;
                }
            }
        };
        for (int i = 0; i < m; i++) bfs2(i, n - 1);
        for (int j = 0; j < n; j++) bfs2(m - 1, j);

        return res;
    }
};
```




### 例题

###### [51. N 皇后](https://leetcode-cn.com/problems/n-queens/)

```cpp
class Solution {
public:
    vector<vector<string>> solveNQueens(int n) {

        vector<vector<string>> res;
        vector<int> c(n);	// c[i]：i行在c[i]列放置皇后
        vector<bool> col(n), pie(n * 2 - 1), na(n * 2 - 1);
        function<void(int)> dfs = [&](int i) {
            // 将要在i行放置皇后
            if (i == n) {
                vector<string> tmp(n, string(n, '.'));
                for (int i = 0; i < n; i++) {
                    tmp[i][c[i]] = 'Q';
                }
                res.emplace_back(move(tmp));
                return;
            }
            for (int j = 0; j < n; j++) {
                if (u1[j] || u2[i + j] || u3[i - j + n - 1]) continue;
                c[i] = j;
                col[j] = pie[i + j] = na[i - j + n - 1] = true;
                dfs(i + 1);
                col[j] = pie[i + j] = na[i - j + n - 1] = false;
            }
        };
        dfs(0);
        return res;
    }
};
```

```cpp
class Solution {
public:
    vector<vector<string>> solveNQueens(int n) {

        vector<vector<string>> res;
        vector<int> c(n);	// c[i]：i行在c[i]列放置皇后
        function<void(int, int, int, int)> dfs = [&](int i, int col, int pie, int na) {
            // 将要在i行放置皇后，列col，副对角线pie，主对角线na
            if (i == n) {
                vector<string> tmp(n, string(n, '.'));
                for (int i = 0; i < n; i++) {
                    tmp[i][c[i]] = 'Q';
                }
                res.emplace_back(move(tmp));
                return;
            }
            int bits = ~(col | pie | na) & ((1 << n) - 1);
            while (bits) {
                int j = bits & -bits;
                c[i] = __builtin_ctz(j);
                dfs(i + 1, (col | j), (pie | j) << 1, (na | j) >> 1);
                bits &= bits - 1;
            }
        };
        dfs(0, 0, 0, 0);
        return res;
    }
};                                                          
```




### 练习

###### [52. N皇后 II](https://leetcode-cn.com/problems/n-queens-ii/)

```cpp
class Solution {
public:
    int totalNQueens(int n) {

        int res = 0;
        vector<bool> col(n), pie(n * 2 - 1), na(n * 2 - 1);
        function<void(int)> dfs = [&](int i) {
            // 将要在i行放置皇后
            if (i == n) {
                res++;
                return;
            }
            for (int j = 0; j < n; j++) {
                if (col[j] || pie[i + j] || na[i - j + n - 1]) continue;
                col[j] = pie[i + j] = na[i - j + n - 1] = true;
                dfs(i + 1);
                col[j] = pie[i + j] = na[i - j + n - 1] = false;
            }
        };
        dfs(0);
        return res;
    }
};
```

```cpp
class Solution {
public:
    int totalNQueens(int n) {

        int res = 0;
        function<void(int, int, int, int)> dfs = [&](int i, int col, int pie, int na) {
            // 将要在i行放置皇后，列col，副对角线pie，主对角线na
            if (i == n) {
                res++;
                return;
            }
            int bits = ~(col | pie | na) & ((1 << n) - 1);
            while (bits) {
                int j = bits & -bits;
                dfs(i + 1, (col | j), (pie | j) << 1, (na | j) >> 1);
                bits &= (bits - 1);
            }
        };
        dfs(0, 0, 0, 0);
        return res;
    }
};
```




###### [37. 解数独](https://leetcode-cn.com/problems/sudoku-solver/)

```cpp
class Solution {
public:
    void solveSudoku(vector<vector<char>>& board) {

        row = col = box = vector<bitset<9>>(9);
        int count = 0;
        for (int i = 0; i < 9; i++) {
            for (int j = 0; j < 9; j++) {
                if (board[i][j] == '.') {
                    count++;
                }
                else {
                    int n = board[i][j] - '1';
                    row[i][n] = col[j][n] = box[b(i, j)][n] = true;
                }
            }
        }
        dfs(count, board);
    }

private:
    vector<bitset<9>> row, col, box;

    int b(int i, int j) {

        return i / 3 * 3 + j / 3;
    }

    auto possible(int i, int j) {
        
        return ~(row[i] | col[j] | box[b(i, j)]);
    }

    auto next(const vector<vector<char>>& board) {
        // 可填整数数量最少的位置
        pair<int, int> res;
        int min_count = INT_MAX;
        for (int i = 0; i < 9; i++) {
            for (int j = 0; j < 9; j++) {
                if (board[i][j] != '.') continue;
                int count = possible(i, j).count();
                if (count < min_count) {
                    res = {i, j};
                    min_count = count;
                }
            }
        }
        return res;
    }
    
    bool dfs(int count, vector<vector<char>>& board) {
        // count：剩余需要填入的空格数量
        if (count == 0) return true;

        auto [i, j] = next(board);
        auto p = possible(i, j);
        int k = b(i, j);
        for (int n = 0; n < 9; n++) {
            if (!p[n]) continue;
            board[i][j] = n + '1';
            row[i][n] = col[j][n] = box[k][n] = true;
            if (dfs(count - 1, board)) return true;
            board[i][j] = '.';
            row[i][n] = col[j][n] = box[k][n] = false;
        }
        return false;
    }
};
```



## Part 9



### 例题

###### [70. 爬楼梯](https://leetcode-cn.com/problems/climbing-stairs/)

```cpp
class Solution {
public:
    int climbStairs(int n) {

        if (n == 0 || n == 1) return 1;
        return climbStairs(n - 1) + climbStairs(n - 2);
    }
};
```

```cpp
class Solution {
public:
    int climbStairs(int n) {

        vector<int> dp(n + 1);
        function<int(int)> dfs = [&](int n) {
            if (n == 0 || n == 1) return 1;
            if (dp[n]) return dp[n];
            return dp[n] = dfs(n - 1) + dfs(n - 2);
        };
        return dfs(n);
    }
};
```


```cpp
class Solution {
public:
    int climbStairs(int n) {

        vector<int> dp(n + 1);
        dp[0] = dp[1] = 1;
        for (int i = 2; i <= n; i++) {
            dp[i] = dp[i - 1] + dp[i - 2];
        }
        return dp[n];
    }
};
```


```cpp
class Solution {
public:
    int climbStairs(int n) {

        int a = 1, b = 1;
        for (int i = 2; i <= n; i++) {
            int c = a + b;
            a = b;
            b = c;
        }
        return b;
    }
};
```


```cpp
class Solution {
public:
    int climbStairs(int n) {

        matrix a{{1, 1}, {1, 0}};
        matrix b = pow(a, n);
        return b[0][0];
    }

private:
    using matrix = vector<vector<int>>;

    matrix mul(matrix& a, matrix& b) {

        matrix c{{0, 0}, {0, 0}};
        for (int i = 0; i < 2; i++) {
            for (int j = 0; j < 2; j++) {
                c[i][j] = a[i][0] * b[0][j] + a[i][1] * b[1][j];
            }
        }
        return c;
    }

    matrix pow(matrix& a, int n) {
        
        matrix b{{1, 0}, {0, 1}};
        while (n) {
            if (n & 1) b = mul(b, a);
            if (!(n >>= 1)) break;
            a = mul(a, a);
        }
        return b;
    }
};
```


```cpp
class Solution {
public:
    int climbStairs(int n) {

        double s = sqrt(5);
        double f = pow((1 + s) / 2, n + 1) - pow((1 - s) / 2, n + 1);
        return f / s;
    }
};
```



### 练习

###### [120. 三角形最小路径和](https://leetcode-cn.com/problems/triangle/)

```cpp
class Solution {
public:
    int minimumTotal(vector<vector<int>>& triangle) {

        const int n = triangle.size();
        vector<int> dp(n); // dp[j]：到达位置(i,j)的最小路径和
        // dp[i][j] = min{ dp[i+1][j], dp[i+1][j+1] }
        for (int i = n - 1; i >= 0; i--) {
            for (int j = 0; j <= i; j++) {
                if (i == n - 1) dp[j] = triangle[i][j];
                else dp[j] = min(dp[j], dp[j + 1]) + triangle[i][j];
            }
        }
        return dp[0];
    }
};
```

```cpp
class Solution {
public:
    int minimumTotal(vector<vector<int>>& triangle) {

        for (int i = triangle.size() - 2; i >= 0; i--) {
            for (int j = 0; j <= i; j++) {
                triangle[i][j] += min(triangle[i + 1][j], triangle[i + 1][j + 1]);
            }
        }
        return triangle[0][0];
    }
};
```




###### [64. 最小路径和](https://leetcode-cn.com/problems/minimum-path-sum/)

```cpp
class Solution {
public:
    int minPathSum(vector<vector<int>>& grid) {

        const int m = grid.size();
        const int n = grid[0].size();
        vector<int> dp(n, INT_MAX); // dp[j]：到达位置(i,j)的最小路径和
        // dp[i][j] = min{ dp[i-1][j], dp[i][j-1] }
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (i == 0 && j == 0) {
                    dp[j] = grid[i][j];
                    continue;
                }
                if (j > 0) dp[j] = min(dp[j], dp[j - 1]);
                dp[j] += grid[i][j];
            }
        }
        return dp[n - 1];
    }
};
```

```cpp
class Solution {
public:
    int minPathSum(vector<vector<int>>& grid) {

        const int m = grid.size();
        const int n = grid[0].size();
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (i == 0 && j == 0) continue;
                if (i == 0) grid[i][j] += grid[i][j - 1];
                else if (j == 0) grid[i][j] += grid[i - 1][j];
                else grid[i][j] += min(grid[i][j - 1], grid[i - 1][j]);
            }
        }
        return grid[m - 1][n - 1];
    }
};
```




### 例题

###### [343. 整数拆分](https://leetcode-cn.com/problems/integer-break/)

```cpp
class Solution {
public:
    int integerBreak(int n) {

        vector<int> dp(n + 1);  // dp[i]：整数i的最大乘积
        dp[1] = 1;
        for (int i = 2; i <= n; i++) {
            for (int j = 1; j <= i / 2; j++) {
                dp[i] = max(dp[i], j * max(i - j, dp[i - j]));
            }
        }
        return dp[n];
    }
};
```

```cpp
class Solution {
public:
    int integerBreak(int n) {

        if (n <= 3) return n - 1;

        int a = n / 3;
        int b = n % 3;
        if (b == 0) return pow(3, a);
        if (b == 1) return pow(3, a - 1) * 4;
        return pow(3, a) * 2;
    }
};
```


```cpp
class Solution {
public:
    int integerBreak(int n) {

        if (n <= 3) return n - 1;

        int a = 1;
        while (n > 4) {
            a *= 3;
            n -= 3;
        }
        return a * n;
    }
};
```




### 练习

###### [279. 完全平方数](https://leetcode-cn.com/problems/perfect-squares/)

```cpp
// 前面出现过
```



###### [91. 解码方法](https://leetcode-cn.com/problems/decode-ways/)

```cpp
class Solution {
public:
    int numDecodings(string s) {

        const int n = s.size();
        vector<int> dp(n + 1);  // dp[i]：前i个字符的解码方法数
        dp[0] = 1;
        for (int i = 1; i <= n; i++) {
            int num = s[i - 1] - '0';
            if (num != 0) dp[i] += dp[i - 1];
            if (i >= 2) {
                num += (s[i - 2] - '0') * 10;
                if (10 <= num && num <= 26) dp[i] += dp[i - 2];
            }
        }
        return dp[n];
    }
};
```

```cpp
class Solution {
public:
    int numDecodings(string s) {

        int a, b = 1;   // dp[i-2]，dp[i-1]
        for (int i = 0; i < s.size(); i++) {
            int c = 0;  // dp[i]
            int num = s[i] - '0';
            if (num) c += b;
            if (i > 0) {
                num += (s[i - 1] - '0') * 10;
                if (10 <= num && num <= 26) c += a;
            }
            a = b;
            b = c;
        }
        return b;
    }
};
```




###### [62. 不同路径](https://leetcode-cn.com/problems/unique-paths/)

```cpp
class Solution {
public:
    int uniquePaths(int m, int n) {

        vector<int> dp(n, 1);  // dp[j]：到达位置(i,j)的路径数
        // dp[i][j] = dp[i-1][j] + dp[i][j-1]
        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {
                dp[j] += dp[j - 1];
            }
        }
        return dp[n - 1];
    }
};
```


```cpp
class Solution {
public:
    int uniquePaths(int m, int n) {

        long res = 1;
        for (int i = n, j = 1; j < m; i++, j++) {
            res = res * i / j;
        }
        return res;
    }
};
```



###### [63. 不同路径 II](https://leetcode-cn.com/problems/unique-paths-ii/)

```cpp
class Solution {
public:
    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {

        const int m = obstacleGrid.size();
        const int n = obstacleGrid[0].size();
        vector<int> dp(n);  // dp[j]：到达位置(i,j)的路径数
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (obstacleGrid[i][j] == 1) dp[j] = 0;
                else if (i == 0 && j == 0) dp[j] = 1;
                else if (j > 0) dp[j] += dp[j - 1];
            }
        }
        return dp[n - 1];
    }
};
```

```cpp
class Solution {
public:
    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {

        const int m = obstacleGrid.size();
        const int n = obstacleGrid[0].size();
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (obstacleGrid[i][j] == 1) {
                    obstacleGrid[i][j] = 0;
                    continue;
                }
                if (i == 0 && j == 0) obstacleGrid[i][j] = 1;
                else if (i == 0) obstacleGrid[i][j] += obstacleGrid[i][j - 1];
                else if (j == 0) obstacleGrid[i][j] += obstacleGrid[i - 1][j];
                else obstacleGrid[i][j] = obstacleGrid[i][j - 1] + obstacleGrid[i - 1][j];
            }
        }
        return obstacleGrid[m - 1][n - 1];
    }
};
```




### 例题

###### [198. 打家劫舍](https://leetcode-cn.com/problems/house-robber/)

```cpp
class Solution {
public:
    int rob(vector<int>& nums) {

        const int n = nums.size();
        vector<int> dp(n + 1);  // dp[i]：前i个房子最多偷到的金币
        dp[0] = 0, dp[1] = nums[0];
        for (int i = 2; i <= n; i++) {
            dp[i] = max(dp[i - 1], dp[i - 2] + nums[i - 1]);
        }
        return dp[n];
    }
};
```

```cpp
class Solution {
public:
    int rob(vector<int>& nums) {

        int a = 0, b = nums[0]; // dp[i-2]，dp[i-1]
        for (int i = 1; i < nums.size(); i++) {
            int c = max(a + nums[i], b);    // dp[i]
            a = b;
            b = c;
        }
        return b;
    }
};
```




### 练习

###### [213. 打家劫舍 II](https://leetcode-cn.com/problems/house-robber-ii/)

```cpp
class Solution {
public:
    int rob(vector<int>& nums) {

        const int n = nums.size();
        if (n == 1) return nums[0];
        
        auto rob = [&](int l, int r) {
            int a = 0, b = nums[l];
            for (int i = l + 1; i <= r; i++) {
                int c = max(a + nums[i], b);
                tie(a, b) = tie(b, c);
            }
            return b;
        };
        return max(rob(0, n - 2), rob(1, n - 1));
    }
};
```



###### [337. 打家劫舍 III](https://leetcode-cn.com/problems/house-robber-iii/)

```cpp
class Solution {
public:
    int rob(TreeNode* root) {

        auto [i, o] = dfs(root);
        return max(i, o);
    }

private:
    pair<int, int> dfs(TreeNode* root) {
        // (i,o)：偷/不偷当前房子的最多金币
        if (!root) return {0, 0};
        
        auto [li, lo] = dfs(root->left);
        auto [ri, ro] = dfs(root->right);
        return {root->val + lo + ro, max(li, lo) + max(ri, ro)};
    }
};
```



###### [309. 最佳买卖股票时机含冷冻期](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/)

```cpp
class Solution {
public:
    int maxProfit(vector<int>& prices) {

        int rest = 0;   // 没有股票
        int buy = INT_MIN;  // 持有股票
        int sell = 0;   // 冷冻期
        for (int p : prices) {
            int last_rest = rest;
            rest = max(rest, sell);
            buy = max(buy, last_rest - p);
            sell = buy + p;
        }
        return max(rest, sell);
    }
};
```



### 例题

###### [416. 分割等和子集](https://leetcode-cn.com/problems/partition-equal-subset-sum/)

```cpp
class Solution {
public:
    bool canPartition(vector<int>& nums) {

        int sum = accumulate(nums.begin(), nums.end(), 0);
        if (sum & 1) return false;

        sum /= 2;
        vector<bool> dp(sum + 1);   // dp[j]：前i个整数可以拼出sum
        // dp[i][j] = dp[i-1][j] or dp[i-1][j-w]
        dp[0] = true;
        for (int n : nums) {
            for (int j = sum; j >= n; j--) {
                dp[j] = dp[j] || dp[j - n];
            }
        }
        return dp[sum];
    }
};
```



### 练习

###### [322. 零钱兑换](https://leetcode-cn.com/problems/coin-change/)

```cpp
class Solution {
public:
    int coinChange(vector<int>& coins, int amount) {

        vector<int> dp(amount + 1, amount + 1); // dp[j]：前i种硬币凑成j的最少数量
        // dp[i][j] = min{ dp[i-1][j], dp[i][j-c] }
        dp[0] = 0;
        for (int c : coins) {
            for (int i = c; i <= amount; i++) {
                dp[i] = min(dp[i], dp[i - c] + 1);
            }
        }
        return dp[amount] <= amount ? dp[amount] : -1;
    }
};
```



###### [377. 组合总和 Ⅳ](https://leetcode-cn.com/problems/combination-sum-iv/)

```cpp
class Solution {
public:
    int combinationSum4(vector<int>& nums, int target) {

        vector<unsigned int> dp(target + 1);    // dp[i]：组成i的方法数
        // dp[i] = sum{ dp[i-w] } w in nums
        dp[0] = 1;
        for (int i = 1; i <= target; i++) {
            for (int n : nums) {
                if (i >= n) dp[i] += dp[i - n];
            }
        }
        return dp[target];
    }
};
```



###### [474. 一和零](https://leetcode-cn.com/problems/ones-and-zeroes/)

```cpp
class Solution {
public:
    int findMaxForm(vector<string>& strs, int m, int n) {

        vector<vector<int>> dp(m + 1, vector<int>(n + 1));
        // dp[j][k]：前i个字符串，j个0，k个1，最大子集大小
        for (const string& s : strs) {
            int count0 = 0, count1 = 0;
            for (char c : s) {
                if (c == '0') count0++;
                else count1++;
            }
            for (int i = m; i >= count0; i--) {
                for (int j = n; j >= count1; j--) {
                    dp[i][j] = max(dp[i][j], dp[i - count0][j - count1] + 1);
                }
            }
        }
        return dp[m][n];
    }
};
```



###### [139. 单词拆分](https://leetcode-cn.com/problems/word-break/)

```cpp
class Solution {
public:
    bool wordBreak(string s, vector<string>& wordDict) {

        string_view t(s);
        const int n = t.size();
        unordered_set<string_view> set(wordDict.begin(), wordDict.end());
        vector<bool> dp(n + 1);  // dp[i]：前i个字符可以被拆分
        dp[0] = true;
        for (int i = 0; i < n; i++) {
            if (!dp[i]) continue;
            for (int j = i + 1; j <= n; j++) {
                if (!dp[j]) dp[j] = set.count(t.substr(i, j - i));
            }
        }
        return dp[n];
    }
};
```


```cpp
class Solution {
public:
    bool wordBreak(string s, vector<string>& wordDict) {

        string_view t(s);
        const int n = t.size();
        vector<bool> dp(n + 1); // dp[i]：前i个字符可以被拆分
        dp[0] = true;
        for (int i = 1; i <= n; i++) {
            for (const string& w : wordDict) {
                int j = i - w.size();
                if (j >= 0 && w == t.substr(j, w.size()) && dp[j]) {
                    dp[i] = true;
                    break;
                }
            }
        }
        return dp[n];
    }
};
```



###### [494. 目标和](https://leetcode-cn.com/problems/target-sum/)

```cpp
class Solution {
public:
    int findTargetSumWays(vector<int>& nums, int S) {

        S = abs(S);
        int sum = accumulate(nums.begin(), nums.end(), 0);
        if (S > sum || (S + sum) & 1) return 0;

        int target = (S + sum) / 2;
        vector<int> dp(target + 1); // dp[j]：前i个整数组成j的方法数
        // dp[i][j] = dp[i-1][j] + dp[i-1][j-a]
        dp[0] = 1;
        for (int n : nums) {
            for (int j = target; j >= n; j--) {
                dp[j] += dp[j - n];
            }
        }
        return dp[target];
    }
};
```



### 例题

###### [300. 最长递增子序列](https://leetcode-cn.com/problems/longest-increasing-subsequence/)

```cpp
class Solution {
public:
    int lengthOfLIS(vector<int>& nums) {

        int res = 0;
        const int n = nums.size();
        vector<int> dp(n);	// dp[i]：以位置i结尾的LIS长度
        // dp[i] = max{ dp[j] } + 1 0<j<i
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < i; j++) {
                if (nums[j] < nums[i]) {
                    dp[i] = max(dp[i], dp[j]);
                }
            }
            res = max(res, ++dp[i]);
        }
        return res;
    }
};
```

```cpp
class Solution {
public:
    int lengthOfLIS(vector<int>& nums) {

        vector<int> res;
        for (int n : nums) {
            auto it = lower_bound(res.begin(), res.end(), n);
            if (it == res.end()) res.emplace_back(n);
            else *it = n;
        }
        return res.size();
    }
};
```




### 练习

###### [376. 摆动序列](https://leetcode-cn.com/problems/wiggle-subsequence/)

```cpp
class Solution {
public:
    int wiggleMaxLength(vector<int>& nums) {

        const int n = nums.size();
        if (n < 2) return n;

        int up = 1, down = 1;
        for (int i = 1; i < n; i++) {
            if (nums[i] > nums[i - 1]) up = down + 1;
            else if (nums[i] < nums[i - 1]) down = up + 1;
        }
        return max(up, down);
    }
};
```

```cpp
class Solution {
public:
    int wiggleMaxLength(vector<int>& nums) {

        const int n = nums.size();
        if (n < 2) return n;

        int prev = nums[1] - nums[0];
        int res = prev ? 2 : 1;
        for (int i = 2; i < n; i++) {
            int curr = nums[i] - nums[i - 1];
            if (curr < 0 && prev >= 0 || curr > 0 && prev <= 0) {
                res++;
                prev = curr;
            }
        }
        return res;
    }
};
```




## Part 10



### 例题

###### [455. 分发饼干](https://leetcode-cn.com/problems/assign-cookies/)

```cpp
class Solution {
public:
    int findContentChildren(vector<int>& g, vector<int>& s) {

        sort(g.begin(), g.end());
        sort(s.begin(), s.end());

        int res = 0;
        int i = 0, j = 0;
        while (i < g.size() && j < s.size()) {
            if (g[i] <= s[j]) res++, i++;
            j++;
        }
        return res;
    }
};
```



### 练习

###### [392. 判断子序列](https://leetcode-cn.com/problems/is-subsequence)

```cpp
class Solution {
public:
    bool isSubsequence(string s, string t) {

        int i = 0, j = 0;
        while (i < s.size() && j < t.size()) {
            if (s[i] == t[j]) i++;
            j++;
        }
        return i == s.size();
    }
};
```


